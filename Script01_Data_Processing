# Part 0: Preparing the environment
knitr::opts_chunk$set(fig.width = 12, 
                      fig.height = 4, 
                      fig.path='Figs/',
                      echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) 
Sys.setenv("LANGUAGE"="En")
Sys.setlocale("LC_ALL", "en_GB.UTF-8")

# packages for data processing
library(openxlsx)
library(readr)
library(questionr)
library(dplyr)
library(plyr)
library(psych)
library(gdata)
library(DescTools)
library(data.table)
library(rlist)
library(nlme)
library(lme4)
library(gtools)

# packages for geolocation and time formats
options(tz = "Asia/Jerusalem")
Sys.setenv(TZ=getOption("tz"))
Sys.getenv("TZ")
library(lubridate)
library(sp)

# packages for social networks analysis
library(asnipe)
library(sna)
library(igraph)
library(devtools)
library(transformr)
library(NetworkToolbox)
library(NetworkComparisonTest)

# packages for plot production
library(ggplot2)
library(ggthemes)
library(ggpubr)
library(gridExtra)
library(RColorBrewer)
library(wesanderson)
theme_set(theme_base())

# packages for network animation
library(network)
library(tidygraph)
library(ggdendro)
library(dendextend)
library(cba) # version ‘0.2.15’

# Part 1: Call data and set the formats right
# Call the data and create the different files for data call
exp_start   <- as.POSIXct("14-07-2017 06:00:00", format = "%d-%m-%Y %H:%M:%S")
exp_end     <- as.POSIXct("10-08-2017 06:00:00", format = "%d-%m-%Y %H:%M:%S")

LoggersBrut <- read.csv(file = paste0("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/01_DeployedLoggers.csv"), 
                        header = TRUE, 
                        sep = ";", 
                        na = c("","NA"))
Loggers              <- LoggersBrut[!is.na(LoggersBrut$Date_on),]
Loggers$Date_on      <- as.Date(strptime(Loggers$Date_on,  "%d/%m/%Y %H:%M"))
Loggers$Date_off     <- as.Date(strptime(Loggers$Date_off, "%d/%m/%Y %H:%M"))
Trapped              <- Loggers[!is.na(Loggers$Date_off),]
List                 <- Loggers[is.na(Loggers$Date_off),]
List$Date_off        <- List$Date_on + months(8)
list_ind             <- rbind(Trapped[data.table::between(exp_start, Trapped$Date_on, Trapped$Date_off),], 
                                 List[data.table::between(exp_start, List$Date_on,    List$Date_off),])
list_ind             <- list_ind[!is.na(list_ind$Chip),]

Contactlist          <- read.csv("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/05_Contactlist.csv", header = T, sep = ",")
Contactlist$interval <- as.POSIXct(strptime(as.character(Contactlist$interval), format = "%Y-%m-%d %H:%M:%S"))
Contactlist$start    <- as.POSIXct(strptime(as.character(Contactlist$start),    format = "%Y-%m-%d %H:%M:%S"))
Contactlist$date     <- as.POSIXct(strptime(as.character(Contactlist$date),     format = "%Y-%m-%d"))

dyads_list           <- read.csv("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/03_Dyads.csv", header = T, sep = ",")
dyads_list           <- dyads_list[dyads_list$deployment==year(exp_start) & dyads_list$retreived=="2_logger",]
li_f                 <- c()
for (day in unique(Contactlist$date)) {
  positions   <- sample(c(1,2), nrow(dyads_list), replace = TRUE)
  logger_out  <- data.frame(out = character(), dyad = character())
  for (index in 1:nrow(dyads_list)) {
    logger_out <- rbind.data.frame(logger_out, 
                        data.frame(out  = dyads_list[index, positions[index]], 
                                   dyad = dyads_list[index, 3]))
  }
  for (pos in 1:nrow(logger_out)) {
    li_1        <- which(Contactlist$dyad        == logger_out[pos, 2])
    li_2        <- which(Contactlist$individual1 == logger_out[pos, 1])
    li_3        <- which(Contactlist$date        == day)
    li_f        <- c(li_f, intersect(intersect(li_1, li_2), li_3))
  }
}
Contactlist          <- Contactlist[-li_f,]
Contactlist$dyad     <- strsplit(as.character(Contactlist$dyad), ":")
TimeEdgelist         <- Contactlist[between(Contactlist$date, exp_start, exp_end),]
TimeEdgelist         <- TimeEdgelist[TimeEdgelist$individual1%in%list_ind$Chip & TimeEdgelist$individual2%in%list_ind$Chip,]
TimeEdgelist         <- TimeEdgelist[TimeEdgelist$duration >= 10,]
TimeEdgelist$Mome    <- (TimeEdgelist$date + dhours(TimeEdgelist$hour)) %>% as.character() %>% as.factor()
TimeEdgelist$site    <- list_ind$Canyon[match(TimeEdgelist$individual1, list_ind$Chip)]



# Part 2: Prepare functions to use in the data analysis.
### FUNCTION 1: Calculates similarity index for several communities
similarity_function  <- function(community, graph){
  
  le.com            <- length(community)
  similarity.matrix <- matrix(0, 
                              nrow = le.com, 
                              ncol = le.com) 
  m                 <- ecount(graph)
  mat               <- as_adjacency_matrix(graph) # recreates the adjacency matrix from the input graph
  
  for (i in 1:le.com){
    for (j in 1:le.com){
      
      sumatory <- 0
      n        <- 1
      
        for (x in 1:length(community[[i]]) ){
          for (y in 1:length(community[[j]])){ 
              
              v <- community[[i]][x]
              w <- community[[j]][y]
              
              if (v != w){
                sum1        <- sum(mat[v,])
                sum2        <- sum(mat[w,])
                sumatory[n] <- mat[v,w] - ((sum1*sum2)/(2*m)) # theoretical background?
                n           <- n + 1 
              }
              
          }
        }
      similarity.matrix[i,j] <- sum(sumatory)/(2*m) # theoretical background?
    }
  }
  diag(similarity.matrix)                         <- NA 
  similarity.matrix[lower.tri(similarity.matrix)] <- NA 

  return(similarity.matrix)

}


### FUNCTION 2: Extended modularity
extended.modularity <- function(grouping, graph, initial.community){ 
  
  m      <- ecount(graph)
  mat    <- as_adjacency_matrix(graph)
  leg    <- length(grouping$labels)
  EQ.cut <- rep(0, times = leg)

  # Calculates the extended modularity for every potential partition 
  for (cut in 1:leg){
    EQ.Ci   <- 0
    cutting <- grouping %>% cutree(k = cut) %>% as.numeric()
    belongs <- rep(0, times = vcount(graph))
  
    # Detects overlapping nodes in the selected partition
    for (Ci in 1:max(cutting)){
      cliques               <- which(cutting == Ci)
      all.nodes.Ci          <- initial.community[cliques] %>% unlist() %>% as.numeric() 
      all.nodes.Ci          <- all.nodes.Ci %>% unique() %>% sort()
      belongs[all.nodes.Ci] <- belongs[all.nodes.Ci] + 1
    }
  
    # Calculates the extended modularity for every community of the selected partition
    for (Ci in 1:max(cutting)){
      cliques      <- which(cutting == Ci)
      all.nodes.Ci <- initial.community[cliques] %>% unlist() %>% as.numeric()
      all.nodes.Ci <- all.nodes.Ci %>% unique() %>% sort()
      EQ.local     <- matrix(0, nrow = length(all.nodes.Ci), ncol = length(all.nodes.Ci)) 
      
      # Calculates the extended modularity for every pair of nodes in the selected community
      for (i in 1:length(all.nodes.Ci)){
        for (j in 1:length(all.nodes.Ci)){
          v             <- all.nodes.Ci[i]
          w             <- all.nodes.Ci[j]
          bv            <- belongs[v]
          bw            <- belongs[w]
          overlap       <- 1 / (bv*bw)
          sum1          <- sum(mat[v,])
          sum2          <- sum(mat[w,])
          EQ.local[i,j] <- overlap*(mat[v,w] - ((sum1*sum2)/(2*m)))
        }
      }
      
      EQ.Ci[Ci] <- sum(EQ.local)
      
    }
  
    EQ.cut[cut] <- (sum(EQ.Ci))/(2*m)
    
  }
  
return(EQ.cut) 

}


### FUNCTION 3: Creates a community object (igraph compatible) with overlapping nodes (maximizes modularity indexes)
overlapping_community <- function(graph_net, output) {
  
  # Find the maximal cliques in a graph (minimum number of nodes per clique is arbitrary set)
  maxCliques <- max_cliques(graph_net)

  # Creates a community structure
  community <- lapply(maxCliques, as.numeric)
  ids       <- unlist(community)
  for (i in 1:vcount(graph_net)){
    if (!is.element(i, ids)==TRUE){ community[length(community)+1] <- i }
  }

  # Name and save the initial community detection based on igraph package
  names(community)                    <- as.character(-1:-length(community)) 
  initial.community                   <- community
  partition.list                      <- list() 
  partition.list[[length(community)]] <- initial.community

  # Calculates the similarity index for matrices created from the initial community structure
  similarity_matrix                   <- similarity_function(community, graph_net)
  initial.similarity                  <- similarity_matrix


  # Merges communities by decreasing similarity scores until only one community is left.
  merge <- matrix(0, nrow = length(community) - 1, ncol = 2) 
  n     <- 1
  while (length(community) != 1) {
    
    # Selects communities to merge (highest similarity score)
    max_sim    <- max(similarity_matrix, na.rm = TRUE)
    to.merge   <- which(similarity_matrix == max_sim, arr.ind = TRUE) 
    x          <- community[[to.merge[1,1]]]
    y          <- community[[to.merge[1,2]]]
    
    # Save merged structure
    merge[n,1] <- names(community[to.merge[1,1]])
    merge[n,2] <- names(community[to.merge[1,2]])
    
    # Merges into the 1st community, re-names the merged community, and deletes the 2nd community
    community[[to.merge[1,1]]]          <- union(x,y) 
    names(community)[to.merge[1,1]]     <- as.character(n) 
    community[[to.merge[1,2]]]          <- NULL
    
    # Calculates the new similarity scores
    similarity_matrix                   <- similarity_function(community, graph_net)
    partition.list[[length(community)]] <- community
    n                                   <- n + 1
  
  }

  # Creates a hclust object to handle the output in R
  grouping                                      <- list()
  class(grouping)                               <- "hclust"
  class(merge)                                  <- "integer"
  grouping$merge                                <- merge
  grouping$height                               <- 1:(length(initial.community)-1)
  initial.similarity[is.na(initial.similarity)] <- 0 
  initial.similarity                            <- initial.similarity + t(initial.similarity) 
  diag(initial.similarity)                      <- 1
  dist.mat                                      <- dist(initial.similarity, method = "euclidean") 
  ordering                                      <- order.optimal(dist.mat, merge)$order
  grouping$order                                <- as.numeric(ordering) 
  dendro.labels                                 <- list()
  
  for (i in 1:length(initial.community)){
    id                 <- initial.community[[i]]
    dendro.labels[[i]] <- paste(V(graph_net)$name[id], collapse=", ") 
  }
  grouping$labels      <- dendro.labels
  
  
  # Selects the partition with the highest extended modularity score (by Shen et al. 2010)
  EQ.cut         <- extended.modularity(grouping, graph_net, initial.community)
  best.partition <- which(EQ.cut == max(EQ.cut))[1]
  
  # Plots the results of the partition as a dendrogram
  steps          <- cbind.data.frame(EQ    = EQ.cut, 
                                     index = c(1:length(EQ.cut)))
  plot1          <- ggplot(steps, aes(x    = index, 
                                      y    = EQ)) + 
                        geom_step() +
                        geom_vline(xintercept = best.partition + 0.5, 
                                   linetype   = 5, 
                                   colour     = "blue") +
                        theme_few() + 
                        ylab("Extended modularity") + 
                        xlab("Potential partitions")
  plot2          <- as.dendrogram(grouping) %>% 
                       #set("branches_k_color", k = best.partition) %>%
                       set("labels", grouping$labels)              %>%
                       set("labels_col", "black")                  %>%
                       as.ggdend()
  plot3          <- ggplot(plot2, horiz = TRUE) +
                       geom_hline(yintercept = max(grouping$height) - best.partition + 1.5,
                                  color      = "blue",
                                  linetype   = 5) +
                       theme_minimal() + 
                       xlab("") + ylab("")
  
  # Creates a table containing memberhsip
  membership <- cutree(as.dendrogram(grouping), k = best.partition) %>% as.data.frame()
  membership <- mutate(membership, n = rownames(membership)) %>% as.data.frame()
  com_member <- unique(membership[,1])
  for (i in com_member) {
    lines    <- which(membership[,1] == i)
    membership[lines, 2] <- membership[lines, 2] %>% 
      strsplit(", ") %>% 
      unlist() %>% 
      unique() %>%   
      paste(collapse = ", ")
  }
  membership     <- membership[!duplicated(membership),]
  membership2    <- strsplit(as.character(membership$n), split = ", ")
  membership2    <- as_membership(membership2)
  membership3    <- list(membership = c(1:length(membership2)), names = membership2)
  
  if (output == "table") {return(list(community = membership3, modularity = max(EQ.cut)))}
  if (output == "plot")  {return(gridExtra::grid.arrange(ggplotGrob(plot1), 
                                                         ggplotGrob(plot3), 
                                                         nrow = 1, 
                                                         ncol = 2))}

}  


### FUNCTION 4: Performes iterative permutations in the dataset.
randomize_within_list <- function(interaction_list, perm, list_ind) {
    
  # Observed network
  interact <- interaction_list
  GBI      <- get_group_by_individual(interact$dyad, data_format = "groups")
  names    <- colnames(GBI)
  missing  <- c(setdiff(as.character(list_ind$Chip), names), 
                setdiff(names, as.character(list_ind$Chip)))
  if (length(missing) > 0) {
    GBI           <- cbind(GBI, matrix(0, 
                                       ncol = length(missing), 
                                       nrow = nrow(GBI)))
    colnames(GBI) <- c(names, as.character(missing))
  }
  invisible(capture.output(Adjacency <- get_network(association_data  =  GBI, 
                             data_format       = "GBI", 
                             association_index = 'SRI', 
                             identities        = colnames(GBI))))
  Adjacency <- Adjacency[order(colnames(Adjacency)),] # sort the rows by names
  Adjacency <- Adjacency[,order(colnames(Adjacency))] # sort the cols by names
  
  # Initializing the array with the observation file
  nline       <- nrow(Adjacency)
  A           <- array(0, c(perm+1, nline, nline))
  A[1,,]      <- Adjacency

  
  # Iterative data-stream permutations
  int         <- interaction_list
  for (iteration in 1:perm) {
    
    # Iterations are limited within each canyon
    for (canyon in unique(list_ind$Canyon)) {
      
      lin_can <- which(int$site==canyon)
      total_c <- length(unique(c(int$individual1[lin_can], int$individual2[lin_can])))
      first_c <- length(unique(int$individual1[lin_can]))
      stop_if <- 0
      
      # If there are only two interacting animals -> no possible swaps
      if (total_c < 3) {
        #print("2 individuals detected")
      }
      
      # If there are 3 animals interacting, we swap two distinct individuals ind3 and ind4, but allow ind1 == ind2
      if (total_c == 3) {
        #print("3 individuals detected")
        repeat {
          # Randomly select two individuals in the focal column
          focals <- sample(as.character(unique(int$individual1[lin_can])), 2, replace = T)
          ind1   <- as.character(focals[1])
          ind2   <- as.character(focals[2])
      
          # Pick two animals they interact with (here we allow ind1 and ind2 to be the same)
          ind3   <- sample(as.character(unique(int$individual2[int$individual1 == ind1])), 1)
          ind4   <- sample(as.character(unique(int$individual2[int$individual1 == ind2])), 1)
          s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
          s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
          l1     <- s1[sample(length(s1), 1, replace = F)]
          l2     <- s2[sample(length(s2), 1, replace = F)]
          
          # Check if the interacting animals are different and if we don't put focals in front of themselves
          if (ind1!=ind4 & ind2!=ind3 & int$site[l1]==int$site[l2]) {
            if (ind3!=ind4) {
              break;
            }
            stop_if <- stop_if + 1
          }
            
          # Breaks the loop after 100 unsuccessful attempts to pick 3 distinct animals
          if (stop_if > 100) {
            break;
          }
        }
        
        #print(paste0(l1, " site = ", int$site[l1]))
        #print(paste0(l2, " site = ", int$site[l2]))  
        # Swaps individual 3 and 4 in the list
        int$individual2[l1] <- ind4
        int$individual2[l2] <- ind3
        
      }
      
      if (total_c > 3) {
        #print(">4 individuals detected")
        if (first_c > 1) {
        
          repeat {
            # Randomly select two distinct individuals in the focal column
            focals <- sample(as.character(unique(int$individual1[lin_can])), 2, replace = F)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
        
            # Check these two individuals are different and pick two animals they interact with
            if (ind1 != ind2) {
            cand3  <- unique(int$individual2[int$individual1 == ind1])
            cand4  <- unique(int$individual2[int$individual1 == ind2])
            ind3   <- sample(as.character(cand3), 1, replace = F)
            ind4   <- sample(as.character(cand4), 1, replace = F)
            s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
            s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
            l1     <- s1[sample(length(s1), 1, replace = F)]
            l2     <- s2[sample(length(s2), 1, replace = F)]
            
            # Check if the two interacting animals are different
            if (!(ind3%in%c(ind1, ind2, ind4)) & !(ind4%in%c(ind1, ind2, ind3)) & int$site[l1]==int$site[l2]) {
              break;
            }
            
            # Breaks the loop after 100 unsuccessful attempts to pick 4 distinct animals
            #if (stop_if > 100) {
            #  break;
            #}
            #stop_if <- stop_if + 1
            }
          }
        
        } else {
        
          repeat {
            # Randomly select one focal individual
            focals <- rep(unique(int$individual1[lin_can]), 2)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            
            # Randomly select two distinct individuals it interacted with
            ind3   <- sample(as.character(unique(int$individual2[int$individual1 == ind1])), 1, replace = F)
            ind4   <- sample(as.character(unique(int$individual2[int$individual1 == ind2])), 1, replace = F)
            s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
            s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
            l1     <- s1[sample(length(s1), 1, replace = F)]
            l2     <- s2[sample(length(s2), 1, replace = F)]
            
            # Check these two animals are different
            if (ind1!=ind4 & ind2!=ind3 & ind3!=ind4 & int$site[l1]==int$site[l2]) {
              break;
            }
            
            # Breaks the loop after 100 unsuccessful attempts to pick 3 distinct animals
            #if (stop_if > 100) {
            #  break;
            #}
            #stop_if <- stop_if + 1
          }
          
        }
       
        #print(paste0("1 = ", ind1, "(", int$individual1[l1], ")", "; 2 = ", ind2, "(", int$individual1[l2], ")"))
        #print(paste0("3 = ", ind3, "(", int$individual2[l1], ")", "; 4 = ", ind4, "(", int$individual2[l2], ")"))
        #print(paste0(l1, " site = ", int$site[l1]))
        #print(paste0(l2, " site = ", int$site[l2])) 
        # Swaps individual 3 and 4 in the list
        int$individual2[l1] <- ind4
        int$individual2[l2] <- ind3
         
      }
      
    }
    
    int$dyad  <- strsplit(paste0(int$individual1, ":", int$individual2), ":")
    
    # Permuted network incrementing the old network
    interact <- int
    GB       <- get_group_by_individual(interact$dyad, data_format = "groups")
    names    <- colnames(GB)
    missing  <- c(setdiff(as.character(list_ind$Chip), names), 
                  setdiff(names, as.character(list_ind$Chip)))
    if (length(missing) > 0) {
      GB           <- cbind(GB, matrix(0, ncol = length(missing), nrow = nrow(GB)))
      colnames(GB) <- c(names, as.character(missing))
    }
    invisible(capture.output(Adjacence <- get_network(association_data  = GB, 
                             data_format       = "GBI", 
                             association_index = 'SRI', 
                             identities        = colnames(GB))))
    Adjacence <- Adjacence[order(colnames(Adjacence)),] # sort the rows by names
    Adjacence <- Adjacence[,order(colnames(Adjacence))] # sort the cols by names
    A[(iteration+1),,] <- Adjacence
    
  }
  
  dimnames(A) <- list(c(1:dim(A)[1]), colnames(Adjacence), colnames(Adjacence))
  return(A)
  
}


### FUNCTION 5: Performes a unique swap in the dataset
unique_swap <- function(interaction_list, list_ind) {
  
  # Iterative data-stream permutations
  int         <- interaction_list
    
    # Iterations are limited within each canyon
    for (canyon in unique(list_ind$Canyon)) {
      
      lin_can <- which(int$site==canyon)
      total_c <- length(unique(c(int$individual1[lin_can], int$individual2[lin_can])))
      first_c <- length(unique(int$individual1[lin_can]))
      stop_if <- 0
      
      # If there are only two interacting animals -> no possible swaps
      if (total_c < 3) {}
      
      # If there are 3 animals interacting, we swap two distinct individuals ind3 and ind4, but allow ind1 == ind2
      if (total_c == 3) {
        repeat {
          # Randomly select two individuals in the focal column
          focals <- sample(as.character(unique(int$individual1[lin_can])), 2, replace = T)
          ind1   <- as.character(focals[1])
          ind2   <- as.character(focals[2])
      
          # Pick two animals they interact with (here we allow ind1 and ind2 to be the same)
          ind3   <- sample(as.character(unique(int$individual2[int$individual1 == ind1])), 1)
          ind4   <- sample(as.character(unique(int$individual2[int$individual1 == ind2])), 1)
          s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
          s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
          l1     <- s1[sample(length(s1), 1, replace = F)]
          l2     <- s2[sample(length(s2), 1, replace = F)]
          
          # Check if the interacting animals are different and if we don't put focals in front of themselves
          if (ind1!=ind4 & ind2!=ind3 & int$site[l1]==int$site[l2]) {
            if (ind3!=ind4) {
              break;
            }
            stop_if <- stop_if + 1
          }
            
          # Breaks the loop after 100 unsuccessful attempts to pick 3 distinct animals
          if (stop_if > 100) {
            break;
          }
        }
        
        # Swaps individual 3 and 4 in the list
        int$individual2[l1] <- ind4
        int$individual2[l2] <- ind3
        
      }
      
      if (total_c > 3) {
        if (first_c > 1) {
          repeat {
            # Randomly select two distinct individuals in the focal column
            focals <- sample(as.character(unique(int$individual1[lin_can])), 2, replace = F)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
        
            # Check these two individuals are different and pick two animals they interact with
            if (ind1 != ind2) {
            cand3  <- unique(int$individual2[int$individual1 == ind1])
            cand4  <- unique(int$individual2[int$individual1 == ind2])
            ind3   <- sample(as.character(cand3), 1, replace = F)
            ind4   <- sample(as.character(cand4), 1, replace = F)
            s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
            s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
            l1     <- s1[sample(length(s1), 1, replace = F)]
            l2     <- s2[sample(length(s2), 1, replace = F)]
            
            # Check if the two interacting animals are different
            if (!(ind3%in%c(ind1, ind2, ind4)) & !(ind4%in%c(ind1, ind2, ind3)) & int$site[l1]==int$site[l2]) {
              break;
            }
            
            }
          }
        } else {
          repeat {
            # Randomly select one focal individual
            focals <- rep(unique(int$individual1[lin_can]), 2)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            
            # Randomly select two distinct individuals it interacted with
            ind3   <- sample(as.character(unique(int$individual2[int$individual1 == ind1])), 1, replace = F)
            ind4   <- sample(as.character(unique(int$individual2[int$individual1 == ind2])), 1, replace = F)
            s1     <- intersect(which(int$individual1==ind1), which(int$individual2==ind3))
            s2     <- intersect(which(int$individual1==ind2), which(int$individual2==ind4))
            l1     <- s1[sample(length(s1), 1, replace = F)]
            l2     <- s2[sample(length(s2), 1, replace = F)]
            
            # Check these two animals are different
            if (ind1!=ind4 & ind2!=ind3 & ind3!=ind4 & int$site[l1]==int$site[l2]) {
              break;
            }
          }
        }
        int$individual2[l1] <- ind4
        int$individual2[l2] <- ind3
      }
      
    }
    
    int$dyad  <- strsplit(paste0(int$individual1, ":", int$individual2), ":")
    return(int)
    
}


### FUNCTION 6: Calculates index of assortativity for continuous traits
individual_assortment_continuous <- function(Adj, list_ind, trait) {
  
  column <- match(trait, colnames(list_ind))
  co     <- c()
  for (i in 1:nrow(Adj)) {
    line <- match(colnames(Adj), list_ind$Chip)
    co   <- c(co, Cor(Adj[i,],                            # Edge weights (i -> other ind)
                    as.numeric(list_ind[line, column])))  # Trait values
  }
  table  <- data.frame(ID      = colnames(Adj), 
                       Index   = co, 
                       Trait   = list_ind[,column])
  return(table)
  
}


### FUNCTION 7: Calculates nodes' attributes on a permuted network and stores them in an array. Also deals with nodes detected in two communities at a time.
get_node_attributes <- function(Array, list_ind, date, phase) {
  
  # Initialize the output dataset
  Node_attr <- array(0, c(dim(Array)[1], dim(Array)[2], 29))
  
  for (step in 1:dim(Array)[1]) {
    
    # Graph creation and nodes attributes setting
    Graph0              <- graph_from_adjacency_matrix(Array[step,,], 
                                                      mode     = "undirected", 
                                                      weighted = TRUE, 
                                                      diag     = TRUE)
    lines               <- match(names(V(Graph0)), list_ind$Chip)
    V(Graph0)$sex       <- as.factor(list_ind$Sex[lines])
    V(Graph0)$group     <- as.factor(list_ind$Group[lines])
    V(Graph0)$canyon    <- as.factor(list_ind$Canyon[lines])
    V(Graph0)$weight    <- as.numeric(as.character(list_ind$Weight[lines]))
    V(Graph0)$dominance <- as.numeric(as.character(list_ind$Normalized_David_score[lines]))
    
    # Split the nodes between canyons (geographic sites)
    for (can in unique(V(Graph0)$canyon)) {
      
      sub_gp    <- names(V(Graph0))[V(Graph0)$canyon == can]
      lin_gp    <- which(dimnames(Array)[[2]]%in%sub_gp)
      sub_ar    <- Array[,lin_gp,lin_gp]
      p_random  <- random_net(sub_ar, perm = (dim(Array)[1] - 1))
      invisible(
        capture.output(
          Graph <- igraph::subgraph(Graph0, v = sub_gp)
        )
      )
      Community <- overlapping_community(Graph, output = "table")
      #Community <- edge.betweenness.community(Graph, directed = FALSE)
      
    
      # Network metrics for each extended community within each canyon
      for (v in names(V(Graph))) {
        
        j      <- which(sapply(Community$community$names, FUN = function(X) v %in% X))
        node.j <- unique(unlist(Community$community$names[j]))
        node.e <- unique(names(unlist(ego(Graph, order = 1, nodes = v, mode = "all"))))
        soc_en <- unique(c(node.e, node.j))
        
        invisible(
          capture.output(
            sub <- igraph::subgraph(Graph, v = soc_en)
          )
        )
        sub    <- as.undirected(sub, mode = c("collapse"), edge.attr.comb = "ignore")
        lic    <- which(dimnames(Array)[[2]]%in%names(V(sub)))
        com_ar <- Array[,lic,lic]
        a      <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes)
        a      <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes) %>% 
                mutate(date                 = date,
                       phase                = phase,
                       p_random_can         = p_random,
                       id_num_com           = paste(j, collapse = "-"),
                       size_com             = graph_order(),
                       modularity_can       = Community$modularity,
                       transitivity_can     = igraph::transitivity(Graph, 
                                                                   type    = "globalundirected", 
                                                                   weights = E(Graph)$weight, 
                                                                   vids    = V(Graph)),
                       transitivity_com     = igraph::transitivity(sub,   
                                                                   type    = "globalundirected", 
                                                                   weights = E(sub)$weight,   
                                                                   vids    = V(sub)),
                       density_can          = graph.density(Graph),
                       density_com          = graph.density(sub),
                       deg_assor_can        = igraph::assortativity.degree(Graph),
                       deg_assor_com        = igraph::assortativity.degree(sub),
                       sex_assor_can        = assortnet::assortment.discrete(sub_ar[step,,], types = V(Graph)$sex, weighted = T)$r,
                       sex_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.discrete(com_ar[step,,], types = V(sub)$sex, weighted = T)$r} else {NA},
                       wei_assor_can        = assortnet::assortment.continuous(sub_ar[step,,], vertex_values = V(Graph)$weight, weighted = T)$r,
                       wei_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.continuous(com_ar[step,,], vertex_values = V(sub)$weight, weighted = T)$r} else {NA},
                       degree               = igraph::degree(Graph)[match(names(V(sub)), names(igraph::degree(Graph)))],
                       local_clustering     = local_transitivity(weights = E(sub)$weight),
                       strength             = centrality_degree(weights = E(sub)$weight, 
                                                                mode    = "all", 
                                                                loops   = FALSE)*100,
                       eigen                = centrality_eigen(weights  = E(sub)$weight, 
                                                               directed = FALSE, 
                                                               scale    = TRUE)*100,
                       betweenness          = centrality_betweenness(weights    = E(sub)$weights, 
                                                                     directed   = FALSE, 
                                                                     normalized = TRUE)*100)
        to_keep <- match(v, as.data.frame(a)$name)                                  
        if (v == names(V(Graph))[1]) {
          c <- as.data.frame(as.data.frame(a)[to_keep,])
        } else {
            c <- rbind.data.frame(c, as.data.frame(a)[to_keep,])
        }
      
      }
      
      # Calculates social differentiation
      for (k in 1:nrow(c)) {
        line                        <- match(c$name[k],colnames(sub_ar[step,,]))
        c$social_differentiation[k] <- var(sub_ar[step,line,])*100
      }
      
      if (can == unique(V(Graph0)$canyon)[1]) {
        b <- as.data.frame(c)}
      else {
        b <- rbind.data.frame(b, as.data.frame(c))
      }
      
    }
    
    d <- as.data.frame(b)
    d <- mutate(d, association_stability = NA)
    Node_attr[step,,] <- as.matrix(d)
    
  }
  
  dimnames(Node_attr) <- list(c(1:dim(Array)[1]), row.names(d), colnames(d))
  return(Node_attr)
  
}



get_node_attributes_per_community <- function(Array, list_ind, date, phase) {
  
  # Initialize the output dataset
  Node_attr <- array(0, c(dim(Array)[1], dim(Array)[2], 28))
  
  for (step in 1:dim(Array)[1]) {
    
    # Graph creation and nodes attributes setting
    Graph0              <- graph_from_adjacency_matrix(Array[step,,], 
                                                      mode     = "undirected", 
                                                      weighted = TRUE, 
                                                      diag     = TRUE)
    lines               <- match(names(V(Graph0)), list_ind$Chip)
    V(Graph0)$sex       <- as.factor(list_ind$Sex[lines])
    V(Graph0)$group     <- as.factor(list_ind$Group[lines])
    V(Graph0)$canyon    <- as.factor(list_ind$Canyon[lines])
    V(Graph0)$weight    <- as.numeric(as.character(list_ind$Weight[lines]))
    V(Graph0)$dominance <- as.numeric(as.character(list_ind$Normalized_David_Score[lines]))
    
    # Split the nodes between canyons (geographic sites)
    for (can in unique(V(Graph0)$canyon)) {
      
      sub_gp    <- names(V(Graph0))[V(Graph0)$canyon == can]
      lin_gp    <- which(dimnames(Array)[[2]]%in%sub_gp)
      sub_ar    <- Array[,lin_gp,lin_gp]
      p_random  <- random_net(sub_ar, perm = (dim(Array)[1] - 1))
      Graph     <- igraph::subgraph(Graph0, v = sub_gp)
      Community <- overlapping_community(Graph, output = "table")
      #Community <- edge.betweenness.community(Graph, directed = FALSE)
      
    
      # Network metrics for each extended community within each canyon
      for (j in as.numeric(Community$community$membership)) {
        
        Soc_en <- ego(Graph, order = 1, nodes = Community$community$names[[j]], mode = "all")
        Soc_en <- unique(unlist(Soc_en))
        
        sub    <- igraph::subgraph(Graph, v = Soc_en)
        sub    <- as.undirected(sub, mode = c("collapse"), edge.attr.comb = "ignore")
        lic    <- which(dimnames(Array)[[2]]%in%names(V(sub)))
        com_ar <- Array[,lic,lic]
        a      <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes)
        a      <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes) %>% 
                mutate(date                 = date,
                       phase                = phase,
                       p_random_can         = p_random,
                       id_num_com           = j,
                       size_com             = graph_order(),
                       modularity_can       = Community$modularity,
                       transitivity_can     = igraph::transitivity(Graph, 
                                                                   type    = "globalundirected", 
                                                                   weights = E(Graph)$weight, 
                                                                   vids    = V(Graph)),
                       transitivity_com     = igraph::transitivity(sub,   
                                                                   type    = "globalundirected", 
                                                                   weights = E(sub)$weight,   
                                                                   vids    = V(sub)),
                       density_can          = graph.density(Graph),
                       density_com          = graph.density(sub),
                       deg_assor_can        = igraph::assortativity.degree(Graph),
                       deg_assor_com        = igraph::assortativity.degree(sub),
                       sex_assor_can        = assortnet::assortment.discrete(sub_ar[step,,], types = V(Graph)$sex, weighted = T)$r,
                       sex_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.discrete(com_ar[step,,], types = V(sub)$sex, weighted = T)$r} else {NA},
                       wei_assor_can        = assortnet::assortment.continuous(sub_ar[step,,], vertex_values = V(Graph)$weight, weighted = T)$r,
                       wei_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.continuous(com_ar[step,,], vertex_values = V(sub)$weight, weighted = T)$r} else {NA},
                       degree               = igraph::degree(Graph)[match(names(V(sub)), names(igraph::degree(Graph)))],
                       local_clustering     = local_transitivity(weights = E(sub)$weight),
                       strength             = centrality_degree(weights = E(sub)$weight, 
                                                                mode    = "all", 
                                                                loops   = FALSE)*100,
                       eigen                = centrality_eigen(weights  = E(sub)$weight, 
                                                               directed = FALSE, 
                                                               scale    = TRUE)*100,
                       betweenness          = centrality_betweenness(weights    = E(sub)$weights, 
                                                                     directed   = FALSE, 
                                                                     normalized = TRUE)*100)
                                          
        if (j == 1) {c <- as.data.frame(a)} else {c <- rbind.data.frame(c, as.data.frame(a))}
      
      }
      
      # Handle multi-membership data
      to_remove <- c()
      tab <- table(c$name)
      for (n in names(tab)[tab > 1]) {
        
        ind_name <- which(n == c$name)
        coms_uni <- c$id_num_com[ind_name]
        environm <- c$name[c$id_num_com %in% coms_uni]
        
        Soc_en <- ego(Graph, order = 1, nodes = environm, mode = "all")
        Soc_en <- unique(unlist(Soc_en))
        
        sub    <- igraph::subgraph(Graph, v = Soc_en)
        sub    <- as.undirected(sub, mode = c("collapse"), edge.attr.comb = "ignore")
        lic    <- which(dimnames(Array)[[2]]%in%names(V(sub)))
        com_ar <- Array[,lic,lic]
        
        a_1    <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes)
        a_1    <- as_tbl_graph(sub) %>% activate(edges) %>% activate(nodes) %>% 
                mutate(date                 = date,
                       phase                = phase,
                       p_random_can         = p_random,
                       id_num_com           = paste(coms_uni, collapse = "-"),
                       size_com             = graph_order(),
                       modularity_can       = Community$modularity,
                       transitivity_can     = igraph::transitivity(Graph, 
                                                                   type    = "globalundirected", 
                                                                   weights = E(Graph)$weight, 
                                                                   vids    = V(Graph)),
                       transitivity_com     = igraph::transitivity(sub,   
                                                                   type    = "globalundirected", 
                                                                   weights = E(sub)$weight,   
                                                                   vids    = V(sub)),
                       density_can          = graph.density(Graph),
                       density_com          = graph.density(sub),
                       deg_assor_can        = igraph::assortativity.degree(Graph),
                       deg_assor_com        = igraph::assortativity.degree(sub),
                       sex_assor_can        = assortnet::assortment.discrete(sub_ar[step,,], types = V(Graph)$sex, weighted = T)$r,
                       sex_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.discrete(com_ar[step,,], types = V(sub)$sex, weighted = T)$r} else {NA},
                       wei_assor_can        = assortnet::assortment.continuous(sub_ar[step,,], vertex_values = V(Graph)$weight, weighted = T)$r,
                       wei_assor_com        = if (length(names(V(sub)))>1) {
                         assortnet::assortment.continuous(com_ar[step,,], vertex_values = V(sub)$weight, weighted = T)$r} else {NA},
                       degree               = igraph::degree(Graph)[match(names(V(sub)), names(igraph::degree(Graph)))],
                       local_clustering     = local_transitivity(weights = E(sub)$weight),
                       strength             = centrality_degree(weights = E(sub)$weight, 
                                                                mode    = "all", 
                                                                loops   = FALSE)*100,
                       eigen                = centrality_eigen(weights  = E(sub)$weight, 
                                                               directed = FALSE, 
                                                               scale    = TRUE)*100,
                       betweenness          = centrality_betweenness(weights    = E(sub)$weights, 
                                                                     directed   = FALSE, 
                                                                     normalized = TRUE)*100)
        
        a_1          <- as.data.frame(a_1)
        new_ind      <- which(n == a_1$name)
        to_remove    <- c(to_remove, ind_name)
        c            <- rbind.data.frame(c, a_1[new_ind,])
        
      }
      
      c <- c[!duplicated(c),]
      if (length(to_remove) > 0) {c <- c[-to_remove,]}
      if (can == unique(V(Graph0)$canyon)[1]) {b <- as.data.frame(c)} else {b <- rbind.data.frame(b, as.data.frame(c))}
      
    }
    
    # Calculates social differentiation
    for (k in 1:nrow(b)) {
      line                        <- match(b$name[k],colnames(Array[step,,]))
      b$social_differentiation[k] <- var(Array[step,line,])*100
    }
    
    # If one node in two communities, summarizes its measures as the mean of all measures
    d <- as.data.frame(b)
    d <- mutate(d, association_stability = NA)
    Node_attr[step,,] <- as.matrix(d)
    
  }
  
  dimnames(Node_attr) <- list(c(1:dim(Array)[1]), row.names(d), colnames(d))
  return(Node_attr)
  
}




### FUNCTION 8: Check if a network is different from random
random_net <- function(Array, perm) {

    t                <- 0
    diag(Array[1,,]) <- NA
    sd_obs           <-   sd(Array[1,,], na.rm = T)
    mean_obs         <- mean(Array[1,,], na.rm = T)
    CV_observed      <- 100*(sd_obs/mean_obs)
    for (index in 1:perm) {
      diag(Array[(index+1),,]) <- NA
      sd_rand        <-   sd(Array[(index+1),,], na.rm = T)
      mean_rand      <- mean(Array[(index+1),,], na.rm = T)
      CV_random      <- 100*(sd_rand/mean_rand)
      if (sum(CV_random, na.rm = T)>0 & sum(CV_observed, na.rm = T)>0) {
        if (CV_random >= CV_observed) {t <- t+1}
      }
    }
  
  return(t/perm)
  
}


### FUNCTION 9: Compares two networks and evaluates statistical significance
compare_networks <- function(metrics_1, metrics_2, perm, names, array_1, array_2, date) {
  
  # Prepare output to calculate local differences
  local_differences <- data.frame(date       = date,
                                  site       = "arugot",
                                  point1     = rep(names[1], dim(metrics_1)[3]-10),
                                  point2     = rep(names[2], dim(metrics_1)[3]-10),
                                  measure    = dimnames(metrics_1)[[3]][11:dim(metrics_1)[3]],
                                  value      = NA,
                                  p.rand.inf = NA,
                                  p.rand.sup = NA,
                                  mean.rand  = NA,
                                  up.rand    = NA,
                                  low.rand   = NA)
  local_differences <- rbind.data.frame(local_differences,
                                        data.frame(date       = date,
                                                   site       = "david",
                                                   point1     = rep(names[1], dim(metrics_1)[3]-10),
                                                   point2     = rep(names[2], dim(metrics_1)[3]-10),
                                                   measure    = dimnames(metrics_1)[[3]][11:dim(metrics_1)[3]],
                                                   value      = NA,
                                                   p.rand.inf = NA,
                                                   p.rand.sup = NA,
                                                   mean.rand  = NA,
                                                   up.rand    = NA,
                                                   low.rand   = NA))
  
  # Fills the empty output
  for (i in 1:nrow(local_differences)) {
    
    if (local_differences$measure[i] == "association_stability") {

      # Observed-network mantel correlation
      q   <- which(tolower(list_ind$Canyon)==local_differences$site[i])
      lin <- which(rownames(array_1[1,,]) %in% list_ind$Chip[q])
      invisible(capture.output(m_1 <- lowerMat(array_1[1,lin,lin])))
      invisible(capture.output(m_2 <- lowerMat(array_2[1,lin,lin])))
      invisible(capture.output(local_differences$value[i] <- ecodist::mantel(m_1 ~ m_2)[1]))
      
      # Permuted-network mantel correlations
      inf <- 0
      sup <- 0
      r   <- c()
      for (j in 1:perm) {
        invisible(capture.output(r_1  <- lowerMat(array_1[j+1,lin,lin])))
        invisible(capture.output(r_2  <- lowerMat(array_2[j+1,lin,lin])))
        invisible(capture.output(corr <- ecodist::mantel(r_1 ~ r_2)[1]))
        r    <- c(r, corr)
        if (local_differences$value[i] < corr) {inf <- inf+1}
        if (local_differences$value[i] > corr) {sup <- sup+1}
      }
    
    } else {
      
      # Observed-network values
      n      <- dim(array_1)[2]
      q      <- which(tolower(list_ind$Canyon)==local_differences$site[i])
      m      <- which(metrics_1[1,(1:n),c("name")] %in% list_ind$Chip[q])
      d1     <- as.data.frame(metrics_1[1,m,]) %>% Sort("name")
      d2     <- as.data.frame(metrics_2[1,m,]) %>% Sort("name")
      x      <- match(local_differences$measure[i], colnames(d1))
      d1[,x] <- d1[,x] %>% as.character() %>% as.numeric() 
      d2[,x] <- d2[,x] %>% as.character() %>% as.numeric()
      if (length(grep("can", local_differences$measure[i])) > 0) {
        v1 <- aggregate(d1[,x],   by = d1[,c("date", "canyon")], FUN = mean, na.action = na.omit)
        v2 <- aggregate(d2[,x],   by = d2[,c("date", "canyon")], FUN = mean, na.action = na.omit)
      } else {
        if (length(grep("com", local_differences$measure[i])) > 0) {
          v1 <- aggregate(d1[,x], by = d1[,c("date", "id_num_com")], FUN = mean, na.action = na.omit)
          v2 <- aggregate(d2[,x], by = d2[,c("date", "id_num_com")], FUN = mean, na.action = na.omit)
          v1$x <- mean(v1$x)
          v2$x <- mean(v2$x)
        } else {
          v1 <- aggregate(d1[,x], by = d1[,c("date", "name")], FUN = mean, na.action = na.omit)
          v2 <- aggregate(d2[,x], by = d2[,c("date", "name")], FUN = mean, na.action = na.omit)
        }
      }
      local_differences$value[i] <- mean(abs(c(v2$x - v1$x)), na.rm = T)
      
      
      # Permuted-network values
      inf <- 0
      sup <- 0
      r   <- c()
      for (j in 1:perm) {
        rand1   <- as.data.frame(metrics_1[(j+1),m,]) %>% Sort("name")
        rand2   <- as.data.frame(metrics_2[(j+1),m,]) %>% Sort("name")
        x       <- match(local_differences$measure[i], colnames(rand1))
        rand1[,x] <- rand1[,x] %>% as.character() %>% as.numeric()
        rand2[,x] <- rand2[,x] %>% as.character() %>% as.numeric()
        if (length(grep("can", local_differences$measure[i])) > 0) {
          r1 <- aggregate(rand1[,x],   by = rand1[,c("date", "canyon")], FUN = mean, na.action = na.omit)
          r2 <- aggregate(rand2[,x],   by = rand1[,c("date", "canyon")], FUN = mean, na.action = na.omit)
        } else {
          if (length(grep("com", local_differences$measure[i])) > 0) {
            r1 <- aggregate(rand1[,x], by = rand1[,c("date", "id_num_com")], FUN = mean, na.action = na.omit)
            r2 <- aggregate(rand2[,x], by = rand2[,c("date", "id_num_com")], FUN = mean, na.action = na.omit)
            r1$x <- mean(r1$x, na.rm = T)
            r2$x <- mean(r2$x, na.rm = T)
          } else {
            r1 <- aggregate(rand1[,x], by = rand1[,c("date", "name")], FUN = mean, na.action = na.omit)
            r2 <- aggregate(rand2[,x], by = rand2[,c("date", "name")], FUN = mean, na.action = na.omit)
          }
        }
        diffval <- mean(abs(c(r2$x - r1$x)), na.rm = T)
        if (!is.na(diffval) & !is.na(local_differences$value[i])) {
          r     <- c(r, abs(r2$x-r1$x))
          if (local_differences$value[i] <= diffval) {inf <- inf+1} # Is the variation day-night smaller than expected? (high value means yes)
          if (local_differences$value[i] >  diffval) {sup <- sup+1} # Is the variation day-night bigger  then expected? 
        } else {next}
      }
        
    }
    
    # Storage in the empty output
    local_differences$p.rand.inf[i] <- 1-(inf/perm) # Is the variation day-night smaller than expected? (low value means yes)
    local_differences$p.rand.sup[i] <- 1-(sup/perm) # Is the variation day-night bigger  than expected?
    local_differences$mean.rand[i]  <- MeanCI(r, na.rm = T)[1]
    local_differences$up.rand[i]    <- MeanCI(r, na.rm = T)[3]
    local_differences$low.rand[i]   <- MeanCI(r, na.rm = T)[2]
    
  }
  
  DiffStage <- as.data.frame(local_differences)
  return(DiffStage)
  
}
```


# Part 3: What are the structural differences between daytime and night-time networks?
data.day <- subset(TimeEdgelist, day_phase %in% c("morning","afternoon"))
data.nig <- subset(TimeEdgelist, day_phase %in% c("night"))
dates    <- levels(as.factor(c(data.day$date, data.nig$date)))
perm     <- 100

for (i in dates[1:length(dates)]) {
  
  # Select the lines for day network and night network that day
  i  <- as.POSIXct(i, format = "%Y-%m-%d")
  d  <- which(data.day$date == i)
  n1 <- intersect(which(data.nig$date==i),         which(data.nig$hour>12))
  n2 <- intersect(which(data.nig$date==i+days(1)), which(data.nig$hour<12))
  
  # Observed lists of interactions
  list_day   <- data.day[d,]
  list_night <- data.nig[c(n1,n2),]
  
  # Creation of the permuted networks
  repeat {
    net_day    <- randomize_within_list(list_day,   perm, list_ind)
    test       <- apply(net_day, 1, sum)
    if ( !(0%in%test) ) {break;} 
  }
  repeat {
    net_night  <- randomize_within_list(list_night, perm, list_ind)
    test       <- apply(net_night, 1, sum)
    if ( !(0%in%test) ) {break;}
  }
  print(paste("Date: ", i, " | Permutations complete."))
  
  # Calculates node attributes and stores observed data
  node_day   <- get_node_attributes(net_day,   list_ind, date = i, phase = "day")
  node_night <- get_node_attributes(net_night, list_ind, date = i, phase = "night")
  node_combi <- Abind(node_day, node_night, along = 2)
  print(paste("Date :", i, " | Nodes' attributes calculated."))
  
  # Calculates differences between stages and statistical significance
  names      <- c("day", "night")
  da_ni_diff <- compare_networks(node_day, node_night, perm, names, net_day, net_night, date = i)
  print(paste("Date :", i, " | First network comparison complete."))
  
  # Store night-time data into a new file for further comparisons
  names             <- c("night", "day")
  if (i > dates[1]) {da_ni_diff_night_before <- compare_networks(node_night_before, node_day, perm, names, net_night_before, net_day, date = i)}
  net_night_before  <- net_night
  node_night_before <- node_night
  print(paste("Date :", i, " | Second network comparison complete."))
  
  # Stores values
  if (i == dates[1]) {
    day.night.diff <- da_ni_diff %>% as.data.frame()
    day.night.data <- node_combi
  } else {
    day.night.diff <- do.call("rbind.data.frame", list(day.night.diff, as.data.frame(da_ni_diff), as.data.frame(da_ni_diff_night_before)))
    day.night.data <- Abind(day.night.data, node_combi, along = 2)
  }
  
}




# Creates two subsets for data analysis: Omnibus and Bayesian model subsets
dates               <- unique(as.data.frame(day.night.data[1,,])$date) %>% as.POSIXct(format = "%Y-%m-%d")
levels              <- expand.grid(dates, c("day", "night")) %>% Sort() %>% as.data.frame()

lines.bayes         <- seq(1, nrow(levels), 3)
lines.omni          <- c(1:nrow(levels))[- lines.bayes]
levels.omni         <- levels[lines.omni,]
levels.omni         <- levels.omni %>% group_by(Var1) %>% filter(row_number() == 1)

levels.bayes        <- levels[lines.bayes,]
levels.bayes        <- levels.bayes %>% group_by(Var1) %>% filter(row_number() == 1)

day.night.diff.omni <- day.night.diff[interaction(day.night.diff$date,day.night.diff$point1) %in% 
                                      interaction(levels.omni$Var1, levels.omni$Var2), ]
day.night.data.1    <- as.data.frame(day.night.data[1,,])
day.night.data.baye <- day.night.data.1[interaction(day.night.data.1$day, day.night.data.1$point1) %in% 
                                        interaction(levels.bayes$Var1, levels.bayes$Var2),]





