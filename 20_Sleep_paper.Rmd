 ---
title: "R Notebook"
output: html_notebook
---

## Nocturnal social networks


# Part 0: Preparing the environment
```{r setup, include = FALSE, message = FALSE}
knitr::opts_chunk$set(fig.width = 12, 
                      fig.height = 4, 
                      fig.path='Figs/',
                      echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) 
Sys.setenv("LANGUAGE"="En")
Sys.setlocale("LC_ALL", "en_GB.UTF-8")

# packages for data processing
library(openxlsx)
library(readr)
library(questionr)
library(dplyr)
library(plyr)
library(psych)
library(gdata)
library(DescTools)
library(data.table)
library(rlist)
library(nlme)
library(lme4)
library(brms)
library(gtools)

# packages for geolocation and time formats
options(tz = "Asia/Jerusalem")
Sys.setenv(TZ=getOption("tz"))
Sys.getenv("TZ")
library(lubridate)
library(sp)
library(suncalc)

# packages for social networks analysis
library(asnipe)
library(sna)
library(igraph)
library(timeordered)
library(devtools)
library(gganimate)
library(transformr)
library(BayesianNetwork)
library(NetworkToolbox)
library(NetworkComparisonTest)

# packages for plot production
library(ggplot2)
library(ggthemes)
library(animation)
library(ggridges)
library(CINNA)
library(ggpubr)
library(gridExtra)
library(RColorBrewer)
library(wesanderson)
theme_set(theme_base())

# packages for network animation
library(network)
library(networkDynamic)
library(ndtv)
library(d3Network)
library(animation)
library(visNetwork)
library(scatterplot3d)
library(tsna)
library(intergraph)
library(tidygraph)
library(ggdendro)
library(dendextend)
library(cba) # version ‘0.2.15’
```

Raw data calling
```{r, message = FALSE, include = FALSE}
set.seed(1)

# Call the data and create the different files for data call
exp_start   <- as.POSIXct("14-07-2017 06:00:00", format = "%d-%m-%Y %H:%M:%S", tz = 'Asia/Jerusalem')
exp_end     <- as.POSIXct("11-08-2017 06:00:00", format = "%d-%m-%Y %H:%M:%S", tz = 'Asia/Jerusalem')
LoggersBrut <- read.csv(file = paste0("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/01_DeployedLoggers.csv"), 
                        header = TRUE, 
                        sep = ";", 
                        na = c("","NA"))
Loggers          <- LoggersBrut[!is.na(LoggersBrut$Date_on),]
Loggers$Date_on  <- as.Date(strptime(Loggers$Date_on,  "%d/%m/%Y %H:%M", tz = 'Asia/Jerusalem'))
Loggers$Date_off <- as.Date(strptime(Loggers$Date_off, "%d/%m/%Y %H:%M", tz = 'Asia/Jerusalem'))

Trapped          <- Loggers[!is.na(Loggers$Date_off),]
List             <- Loggers[is.na(Loggers$Date_off),]
List$Date_off    <- List$Date_on + months(8)
list_ind         <- rbind(Trapped[data.table::between(exp_start, Trapped$Date_on, Trapped$Date_off),], 
                          List[data.table::between(exp_start, List$Date_on,    List$Date_off),])
list_ind         <- list_ind[!is.na(list_ind$Chip),]

sunlight    <- read.csv("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/06_sunlightTimes.csv", header = T)
dyads_list  <- read.csv("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/03_Dyads.csv", header = T, sep = ",")
dyads_list  <- dyads_list[dyads_list$deployment==year(exp_start),]
dyads_list  <- dyads_list[dyads_list$retreived=="2_logger",]

Contactlist <- read.csv("~/Dropbox/Hyraxes/Projects/2019_Camille_Chu_ProximityData/05_ContactlistExtended.csv", header = T, sep = ",")
Contactlist$interval <- as.POSIXct(strptime(as.character(Contactlist$interval), 
                                            format = "%Y-%m-%d %H:%M:%S", tz = 'Asia/Jerusalem'))
Contactlist$start <- as.POSIXct(strptime(as.character(Contactlist$start), format = "%Y-%m-%d %H:%M:%S", tz = 'Asia/Jerusalem'))
Contactlist$date  <- as.POSIXct(strptime(as.character(Contactlist$date), format = "%Y-%m-%d", tz = 'Asia/Jerusalem'))
li_f              <- c()
for (day in unique(Contactlist$date)) {
  positions   <- sample(c(1,2), nrow(dyads_list), replace = TRUE)
  logger_out  <- data.frame(out = character(), dyad = character())
  for (index in 1:nrow(dyads_list)) {
    logger_out <- rbind.data.frame(logger_out, 
                        data.frame(out  = dyads_list[index, positions[index]], 
                                   dyad = dyads_list[index, 3]))
  }
  for (pos in 1:nrow(logger_out)) {
    li_1        <- which(Contactlist$dyad        == logger_out[pos, 2])
    li_2        <- which(Contactlist$individual1 == logger_out[pos, 1])
    li_3        <- which(Contactlist$date        == day)
    li_f        <- c(li_f, intersect(intersect(li_1, li_2), li_3))
  }
}
Contactlist          <- Contactlist[-li_f,]
Contactlist$chip     <- Contactlist$dyad
Contactlist$dyad     <- strsplit(as.character(Contactlist$dyad), ":")
TimeEdgelist         <- Contactlist[between(Contactlist$interval, exp_start, exp_end),]
TimeEdgelist         <- TimeEdgelist[TimeEdgelist$individual1%in%list_ind$Chip & TimeEdgelist$individual2%in%list_ind$Chip,]
TimeEdgelist$Mome    <- (TimeEdgelist$date + dhours(TimeEdgelist$hour)) %>% as.character() %>% as.factor()
TimeEdgelist$site    <- list_ind$Canyon[match(TimeEdgelist$individual1, list_ind$Chip)]
TimeEdgelist$phase   <- "other"
TimeEdgelist$phase[TimeEdgelist$day_phase %in% c("morning", "afternoon")] <- "day"
TimeEdgelist$phase[TimeEdgelist$day_phase %in% c("early_night", "late_night")] <- "night"
TimeEdgelist         <- TimeEdgelist[TimeEdgelist$duration > 10,] 
for (ip in 1:nrow(TimeEdgelist)) {
  TimeEdgelist$n5[ip] <- sunlight$n5[TimeEdgelist$phase[ip]==sunlight$phase2 & TimeEdgelist$date[ip]==sunlight$date]
}

gbi_full <- get_group_by_individual(TimeEdgelist$dyad, data_format = "groups")
invisible(
  capture.output(
    net_full <- get_network(association_data  =  gbi_full, 
                            data_format       = "GBI", 
                            association_index = 'SRI', 
                            identities        = colnames(gbi_full))
  )
)
gra_full <- graph_from_adjacency_matrix(net_full, "undirected", weighted = T)
Community    <- linkcomm::getOCG.clusters(get.edgelist(gra_full))
adds         <- setdiff(names(V(gra_full)), Community$nodeclusters$node)
max          <- as.numeric(max(Community$nodeclusters$cluster))
if (length(adds > 0)) {
  Community$nodeclusters    <- rbind(Community$nodeclusters,
                                   data.frame(node = adds,
                                              cluster = max+c(1:length(adds))))
}
Community$nodeclusters$ID <- 1:nrow(Community$nodeclusters)  # unique variable
lst <- Community$nodeclusters %>% tidyr::spread(cluster, node) %>% select(-ID) %>% as.list()
lapply(lst, function(x) x[!is.na(x)])

TimeEdgelist$g1 <- "between"
for (dd in unique(TimeEdgelist$chip)) {
  
  inds <- strsplit(dd, split = ":")
  ind1 <- inds[[1]][1]
  ind2 <- inds[[1]][2]
  p1   <- 1 * sapply(lst, `%in%`, x = ind1)
  p2   <- 1 * sapply(lst, `%in%`, x = ind2)
  if (any(p1&p2)) {TimeEdgelist$g1[which(TimeEdgelist$chip==dd)] <- "within"}

}
TimeEdgelist$category <- cut(TimeEdgelist$duration, 
                              breaks = c(10, 25*60, 50*60, 75*60, 100*60, 125*60, 150*60, Inf), 
                              labels = c("<25", "25-50", "50-75", "75-100", "100-125", "125-150", ">150"))
table(TimeEdgelist$category)/nrow(TimeEdgelist)
table(TimeEdgelist$category[TimeEdgelist$phase=="night"])/nrow(TimeEdgelist[TimeEdgelist$phase=="night",])
table(TimeEdgelist$category[TimeEdgelist$phase=="day"])/nrow(TimeEdgelist[TimeEdgelist$phase=="day",])
```

Functions for this data analysis
```{r}
get_that_network <- function(interaction_list, list_ind, exclude = FALSE) {
  
  gbi <- get_group_by_individual(interaction_list$dyad, data_format = "groups")
  n   <- length(colnames(gbi))
  net <- matrix(0, nrow = n, ncol = n)
  colnames(net) <- colnames(gbi)
  rownames(net) <- colnames(gbi)
  
  for (i in 1:nrow(gbi)){
    for(j in 1:n){
      for(k in 1:n){
        if(j!=k){
          if(gbi[i,j]==1 & gbi[i,k]==1) {net[j,k] <- net[j,k]+1} else {next}
        } else {next}
      }
    }
  }
  t_ij <- interaction_list$n5[1]
  if (exclude) {
      t_ij <- t_ij - length(unique(inte$interval[interaction_list$duration>=(55*60)]))
  }
  net <- net/t_ij
  
  return(net)
  
}

randomize_within_list <- function(interaction_list, perm, list_ind, community) {
    
  interact <- interaction_list
  GBI      <- get_group_by_individual(interact$dyad, data_format = "groups")
  names    <- colnames(GBI)
  missing  <- c(setdiff(as.character(list_ind$Chip), names), 
                setdiff(names, as.character(list_ind$Chip)))
  if (length(missing) > 0) {
    GBI           <- cbind(GBI, matrix(0, 
                                       ncol = length(missing), 
                                       nrow = nrow(GBI)))
    colnames(GBI) <- c(names, as.character(missing))
  }
  invisible(
    capture.output(
      Adjacency <- get_network(
        association_data  =  GBI, 
        data_format       = "GBI", 
        association_index = 'SRI', 
        identities        = colnames(GBI)
        )
      )
    )
  Adjacency   <- Adjacency[order(colnames(Adjacency)),] # sort the rows by names
  Adjacency   <- Adjacency[,order(colnames(Adjacency))] # sort the cols by names
  nline       <- nrow(Adjacency)
  A           <- array(0, c(perm+1, nline, nline))
  A[1,,]      <- Adjacency
  
  int         <- interaction_list
  for (iteration in 1:perm) {
    
    # Iterations are limited within each community
    for (com in unique(community$nodeclusters$cluster)) {
      
      swap_id <- as.numeric(community$nodeclusters$node[which(community$nodeclusters$cluster==com)])
      lin_co1 <- which(int$individual1%in%swap_id)
      lin_co2 <- which(int$individual2%in%swap_id)
      lin_com <- union(lin_co1, lin_co2)
      total_c <- length(unique(c(int$individual1[lin_com], int$individual2[lin_com])))
      first_c <- length(unique(int$individual1[lin_com]))
      stop_if <- 0
      
      if (total_c > 3) {
        if (first_c > 1) {
          repeat {
            focals <- sample(as.character(unique(int$individual1[lin_com])), 2, replace = F)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            if (ind1!=ind2) {
              cand3  <- unique(int$individual2[int$individual1==ind1 & int$individual2!=ind2])
              lines3 <- intersect(which(int$individual1==ind1), which(int$individual2%in%cand3))
              if (length(lines3)>0) {
                l1     <- sample(lines3, 1, replace = F)
                ind3   <- as.character(int$individual2[l1])
                cand4  <- unique(int$individual2[int$individual1==ind2 & int$individual2!=ind1])
                lines4 <- intersect(which(int$individual1==ind2), which(int$individual2%in%cand4))
                lines4 <- intersect(which(int$individual2!=ind3), lines4)
                if (length(lines4)>0) {
                  l2     <- sample(lines4, 1, replace = F)
                  ind4   <- as.character(int$individual2[l2])
                  if (!(ind3%in%c(ind1, ind2, ind4)) & !(ind4%in%c(ind1, ind2, ind3)) & int$site[l1]==int$site[l2]) {
                    break;
                  }
                }
              }
            }
            stop_if <- stop_if + 1
            if (stop_if==1000) {break}
          }
        } else {
          repeat {
            focals <- rep(unique(int$individual1[lin_com]), 2)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            cand3  <- unique(int$individual2[int$individual1==ind1 & int$individual2!=ind2])
            lines3 <- intersect(which(int$individual1==ind1), which(int$individual2%in%cand3))
            if (length(lines3)>0) {
              l1     <- sample(lines3, 1, replace = F)
              ind3   <- as.character(int$individual2[l1])
              cand4  <- unique(int$individual2[int$individual1==ind2 & int$individual2!=ind1])
              lines4 <- intersect(which(int$individual1==ind2), which(int$individual2%in%cand4))
              lines4 <- intersect(which(int$individual2!=ind3), lines4)
              if(length(lines4)>0) {
                l2     <- sample(lines4, 1, replace = F)
                ind4   <- as.character(int$individual2[l2])
                if (ind1!=ind4 & ind2!=ind3 & ind3!=ind4 & int$site[l1]==int$site[l2]) {
                  break;
                }
              }
            }
            stop_if <- stop_if + 1
            if (stop_if==1000) {break}
          }
        }
        if (stop_if==1000 & length(l2)==0) {
          l2   <- l1
          ind4 <- ind3
        }
        sl1 <- int$start[l1]
        i1l1<- int$individual1[l1]
        i2l1<- int$individual2[l1]
        all1<- intersect(which(int$start==sl1), 
                         intersect(which(int$individual1==i1l1), 
                                   which(int$individual2==i2l1)
                                   )
                         )
        sl2 <- int$start[l2]
        i1l2<- int$individual1[l2]
        i2l2<- int$individual2[l2]
        all2<- intersect(which(int$start==sl2), 
                         intersect(which(int$individual1==i1l2), 
                                   which(int$individual2==i2l2)
                                   )
                         )
        int$individual2[all1] <- ind4
        int$individual2[all2] <- ind3
      }
      
    }
    int$dyad  <- strsplit(paste0(int$individual1, ":", int$individual2), ":")
    
    interact <- int
    GB       <- get_group_by_individual(interact$dyad, data_format = "groups")
    names    <- colnames(GB)
    missing  <- c(setdiff(as.character(list_ind$Chip), names), 
                  setdiff(names, as.character(list_ind$Chip)))
    if (length(missing) > 0) {
      GB           <- cbind(GB, matrix(0, ncol = length(missing), nrow = nrow(GB)))
      colnames(GB) <- c(names, as.character(missing))
    }
    invisible(
      capture.output(
        Adjacence <- get_network(
          association_data  = GB, 
          data_format       = "GBI", 
          association_index = 'SRI', 
          identities        = colnames(GB)
          )
        )
      )
    Adjacence <- Adjacence[order(colnames(Adjacence)),] # sort the rows by names
    Adjacence <- Adjacence[,order(colnames(Adjacence))] # sort the cols by names
    A[(iteration+1),,] <- Adjacence
    
  }
  
  dimnames(A) <- list(c(1:dim(A)[1]), colnames(Adjacence), colnames(Adjacence))
  return(A)
  
}

unique_swap <- function(interaction_list, list_ind, community) {
  
  # Iterative data-stream permutations
  int         <- interaction_list
    
    # Iterations are limited within each canyon
    for (com in unique(community$nodeclusters$cluster)) {
      
      swap_id <- as.numeric(community$nodeclusters$node[which(community$nodeclusters$cluster==com)])
      lin_co1 <- which(int$individual1%in%swap_id)
      lin_co2 <- which(int$individual2%in%swap_id)
      lin_com <- union(lin_co1, lin_co2)
      total_c <- length(unique(c(int$individual1[lin_com], int$individual2[lin_com])))
      first_c <- length(unique(int$individual1[lin_com]))
      stop_if <- 0
      
      if (total_c > 3) {
        if (first_c > 1) {
          repeat {
            focals <- sample(as.character(unique(int$individual1[lin_com])), 2, replace = F)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            if (ind1!=ind2) {
              cand3  <- unique(int$individual2[int$individual1==ind1 & int$individual2!=ind2])
              lines3 <- intersect(which(int$individual1==ind1), which(int$individual2%in%cand3))
              if (length(lines3)>0) {
                l1     <- sample(lines3, 1, replace = F)
                ind3   <- as.character(int$individual2[l1])
                cand4  <- unique(int$individual2[int$individual1==ind2 & int$individual2!=ind1])
                lines4 <- intersect(which(int$individual1==ind2), which(int$individual2%in%cand4))
                lines4 <- intersect(which(int$individual2!=ind3), lines4)
                if (length(lines4)>0) {
                  l2     <- sample(lines4, 1, replace = F)
                  ind4   <- as.character(int$individual2[l2])
                  if (!(ind3%in%c(ind1, ind2, ind4)) & !(ind4%in%c(ind1, ind2, ind3)) & int$site[l1]==int$site[l2]) {
                    break;
                  }
                }
              }
            }
            stop_if <- stop_if + 1
            if (stop_if==1000) {break}
          }
        } else {
          repeat {
            focals <- rep(unique(int$individual1[lin_com]), 2)
            ind1   <- as.character(focals[1])
            ind2   <- as.character(focals[2])
            cand3  <- unique(int$individual2[int$individual1==ind1 & int$individual2!=ind2])
            lines3 <- intersect(which(int$individual1==ind1), which(int$individual2%in%cand3))
            if (length(lines3)>0) {
              l1     <- sample(lines3, 1, replace = F)
              ind3   <- as.character(int$individual2[l1])
              cand4  <- unique(int$individual2[int$individual1==ind2 & int$individual2!=ind1])
              lines4 <- intersect(which(int$individual1==ind2), which(int$individual2%in%cand4))
              lines4 <- intersect(which(int$individual2!=ind3), lines4)
              if(length(lines4)>0) {
                l2     <- sample(lines4, 1, replace = F)
                ind4   <- as.character(int$individual2[l2])
                if (ind1!=ind4 & ind2!=ind3 & ind3!=ind4 & int$site[l1]==int$site[l2]) {
                  break;
                }
              }
            }
            stop_if <- stop_if + 1
            if (stop_if==1000) {break}
          }
        }
        if (stop_if==1000 & length(l2)==0) {
          l2   <- l1
          ind4 <- ind3
        }
        sl1 <- int$start[l1]
        i1l1<- int$individual1[l1]
        i2l1<- int$individual2[l1]
        all1<- intersect(which(int$start==sl1), 
                         intersect(which(int$individual1==i1l1), 
                                   which(int$individual2==i2l1)
                                   )
                         )
        sl2 <- int$start[l2]
        i1l2<- int$individual1[l2]
        i2l2<- int$individual2[l2]
        all2<- intersect(which(int$start==sl2), 
                         intersect(which(int$individual1==i1l2), 
                                   which(int$individual2==i2l2)
                                   )
                         )
        int$individual2[all1] <- ind4
        int$individual2[all2] <- ind3
        int$dyad[all1] <- paste0(min(int$individual1[l1], ind4), ":", max(int$individual1[l1], ind4))
        int$dyad[all2] <- paste0(min(int$individual1[l2], ind3), ":", max(int$individual1[l2], ind3))
        
      }
      
    }
  
  int$dyad <- strsplit(paste0(int$individual1, ":", int$individual2), ":")
  return(int)
    
}

random_net <- function(Array, perm) {

    t                <- 0
    diag(Array[1,,]) <- NA
    sd_obs           <-   sd(Array[1,,], na.rm = T)
    mean_obs         <- mean(Array[1,,], na.rm = T)
    CV_observed      <- 100*(sd_obs/mean_obs)
    for (index in 1:perm) {
      diag(Array[(index+1),,]) <- NA
      sd_rand        <-   sd(Array[(index+1),,], na.rm = T)
      mean_rand      <- mean(Array[(index+1),,], na.rm = T)
      CV_random      <- 100*(sd_rand/mean_rand)
      if (sum(CV_random, na.rm = T)>0 & sum(CV_observed, na.rm = T)>0) {
        if (CV_random >= CV_observed) {t <- t+1}
      }
    }
  
  return(t/perm)
  
}
```



# PART 01: What do hyraxes do at night?
Duration threshold between "sleep" and "awake"
```{r}
perm     <- 1000
for (m in seq(0, 100, 5)) {
  
  encounters <- TimeEdgelist[data.table::between(TimeEdgelist$duration,(m*60) ,(max(TimeEdgelist$duration)*60)) ,]
  encounters <- encounters[encounters$phase=="night" ,]
  
  if (dim(encounters)[1] != 0) {
    
    net <- randomize_within_list(encounters, perm = perm, list_ind = list_ind, community = Community)
    gri <- graph_from_adjacency_matrix(net[1,,], mode = "undirected", weighted = T)

    if (m==0) {
      Nets.mosaic <- net
      names.dim <- c(m)
      average.s <- c(mean(unname(igraph::strength(gri)), na.rm = T))
      std.err.s <- c(MeanSE(unname(igraph::strength(gri)), na.rm = T))
      std.dev.s <- c(unname(igraph::strength(gri)))
    } else {
      Nets.mosaic <- DescTools::Abind(Nets.mosaic, net, along = 1)
      names.dim <- c(names.dim, m)
      average.s <- c(average.s, mean(unname(igraph::strength(gri)), na.rm = T))
      std.err.s <- c(std.err.s, MeanSE(unname(igraph::strength(gri)), na.rm = T))
      std.dev.s <- c(std.dev.s, unname(igraph::strength(gri)))
    }
    
    print(paste("Done: ", m))
    
  }
  
}



m <- 1
for (k in seq(1, dim(Nets.mosaic)[1]-((2*perm)+1), (perm+1))) {
  
  n <- m + 1
  for (l in seq(k+(perm+1), dim(Nets.mosaic)[1]-perm, (perm+1))) {
    
    invisible(capture.output(A <- psych::lowerMat(Nets.mosaic[k,,])))
    invisible(capture.output(B <- psych::lowerMat(Nets.mosaic[l,,])))
    r <- ecodist::mantel(A ~ B)[1]
    s <- lsa::cosine(A, B)
    
    t1 <- 0
    t2 <- 0
    for (p in 1:perm) {
      invisible(capture.output(A <- psych::lowerMat(Nets.mosaic[k+p,,])))
      invisible(capture.output(B <- psych::lowerMat(Nets.mosaic[l+p,,])))
      u <- ecodist::mantel(A ~ B)[1]
      v <- lsa::cosine(A, B)
      if (u < r) {t1 <- t1+1}
      if (v < s) {t2 <- t2+1}
    }
    
    if (m == 1 & n == 2) {
      mosaic.data <- data.frame(X = names.dim[m],
                                Y = names.dim[n],
                                R.mantel = r,
                                P.mantel = t1/perm,
                                R.cosine = s,
                                P.cosine = t2/perm)
    } else {
      mosaic.data <- rbind.data.frame(mosaic.data,
                     data.frame(X = names.dim[m],
                                Y = names.dim[n],
                                R.mantel = r,
                                P.mantel = t1/perm,
                                R.cosine = s,
                                P.cosine = t2/perm))
    }
    
    n <- n + 1
    
  }
  
  print(paste0("You have completed ", m, "/50 window scans."))
  m <- m + 1
  
}
mosaic.data5 <- mosaic.data
mosaic.data5$P.transform <- mosaic.data5$P.cosine
mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5] <- 1 - mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5]
mosaic.data5$P.adjust <- stats::p.adjust(mosaic.data5$P.transform, method = "fdr")
mosaic.data5$class.w <- "white"
mosaic.data5$class.w[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine<0.5] <- "cornflowerblue"
mosaic.data5$class.w[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine>0.5] <- "tomato"


mosaic.data1 <- rbind.data.frame(mosaic.data5,
                      data.frame(X = mosaic.data5[,2],
                                 Y = mosaic.data5[,1],
                                 R.mantel = mosaic.data5[,3],
                                 P.mantel = mosaic.data5[,4],
                                 R.cosine = mosaic.data5[,5],
                                 P.cosine = mosaic.data5[,6],
                                 P.transform = mosaic.data5[,7],
                                 P.adjust   = mosaic.data5[,8],
                                 class.w    = mosaic.data5[,9]))
#write.csv(x = mosaic.data1, file = "/Users/bordescamille/Desktop/mosaic.data1.csv", quote = F, row.names = F)

filter.strength <- data.frame(window = seq(0, 100, 5), 
                              mean_s = average.s, 
                              vari_s = std.err.s,
                              std_s  = std.dev.s)
#write.csv(x = filter.strength, file = "/Users/bordescamille/Desktop/average.strength.centrality.csv", quote = F, row.names = F)

ww <- data.frame(sd = std.dev.s, window = rep(seq(0, 100, 5), each = 30))
#write.csv(x = ww, file = "/Users/bordescamille/Desktop/rwa.strength.csv", quote = F, row.names = F)
```

```{r}
mosaic.data1 <- read.csv("~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_01_NighttimeSociality/mosaic.data1.csv", header = T)
filter.strength <- read.csv("~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_01_NighttimeSociality/average.strength.centrality.csv", header = T)

a <- ggplot(mosaic.data1, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = R.cosine)) + 
  geom_tile(width = 4, 
            height = 4) +
  geom_rect(aes(xmin = 0-2.5, xmax = 25-2.5,
                ymin = 0-2.5, ymax = 25-2.5),
            color = "red",
            fill = NA) +
    geom_rect(aes(xmin = 25-2.5, xmax = 100+2.5,
                  ymin = 25-2.5, ymax = 100+2.5),
            color = "red",
            fill = NA) +
  scale_fill_gradient2(low      = "cornflowerblue", 
                       high     = "tomato", 
                       mid      = "lightyellow", 
                       na.value = "white",
                       midpoint = mean( mosaic.data1$R.cosine, na.rm = T), 
                       limit    = c(min(mosaic.data1$R.cosine, na.rm = T), 
                                    max(mosaic.data1$R.cosine, na.rm = T)),
                       breaks   = c(min(mosaic.data1$R.cosine, na.rm = T),
                                    mean( mosaic.data1$R.cosine, na.rm = T),
                                    max(mosaic.data1$R.cosine, na.rm = T)),
                       labels   = c(as.character(round(min(mosaic.data1$R.cosine, na.rm = T)*100)/100),
                                    as.character(round(mean( mosaic.data1$R.cosine, na.rm = T)*100)/100),
                                    as.character(round(max(mosaic.data1$R.cosine, na.rm = T)*100)/100)),
                       name     = "") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  ylab("cut-off (minutes)") +
  xlab("cut-off (minutes)") +
  theme_few() + 
  theme(
    plot.title          = element_blank(),
    axis.text.x         = element_text(angle = 0, 
                                     size  = 15,
                                     color = "black"),
    axis.text.y         = element_text(angle = 0,
                                     size  = 15,
                                     color = "black"),
    axis.title.x         = element_text(vjust = -3, size = 18),
    axis.title.y         = element_text(angle = 90,
                                     color = "black",
                                     vjust = 5,
                                     size = 18),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    plot.margin          = unit(c(0, 1, 0.5, 0), "cm"),
    axis.ticks           = element_blank(),
    legend.justification = c(1, 0),
    legend.direction     = "horizontal",
    legend.position      = "bottom",
    legend.text          = element_text(size = 12),
    legend.title         = element_text(size  = 15)) +
  guides(fill = guide_colorbar(barwidth       = 7, 
                               barheight      = 1,
                               title.position = "left",
                               title.hjust    = 0.5))


b <- ggplot(mosaic.data1, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = class.w)) + 
  geom_tile() +
    geom_vline(xintercept = 25-2.5,
             col = "darkred") +
  geom_hline(yintercept = 25-2.5,
             color = "darkred") +
  scale_fill_manual(breaks = c("cornflowerblue", "tomato", "white"),
                    values = c("cornflowerblue", "tomato", "white"),
                    labels = c("Lower than random", 
                               "Higher than random",
                               "Non significant"),
                    name = "Observed value is:") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +
  theme(
    plot.title          = element_text(hjust = 0.5,
                                       size  = 18),
    axis.text.x         = element_text(angle = 45, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "white"),
    axis.text.y         = element_text(angle = 0, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "white"),
    axis.title.x         = element_blank(),
    axis.title.y         = element_blank(),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.direction     = "vertical",
    legend.position      = "none") +
  ggtitle("Associated p-values")

c <- ggplot(filter.strength, aes(x = window, 
                            y = mean_s)) +
  geom_errorbar(aes(x = window,
                    ymin = mean_s - vari_s,
                    ymax = mean_s + vari_s),
                width = 0) +
  geom_point() +
  ylab("strength centrality") +
  theme_pubr() +
  theme(axis.title.x  = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x  = element_blank(),
        axis.line.x  = element_blank(), 
        axis.title.y = element_text(vjust = 5, size = 18),
        plot.margin  = unit(c(2,1,-0.5,1), "cm"))

ggarrange(c, a, ncol = 1, nrow = 2, align = "v", heights = c(1, 3.4), legend = "bottom")
```

Correlation matrix between time periods (longs VS short contacts)
```{r}
dates  <- as.character(unique(TimeEdgelist$date))
phases <- c("day", "night")
n      <- length(unique(list_ind$Chip))
ind    <- unique(list_ind$Chip)

# for (i in dates) {
  
  for (j in phases) {
    
    for (k in c("short", "long")) {
      
      #if (j=="day") {
        # d <- which(TimeEdgelist$date == i)
        #p <- which(TimeEdgelist$phase == j)
        #l <- intersect(d, p)
      #} else {
        # d1 <- which(TimeEdgelist$date ==i)
        #p1 <- which(TimeEdgelist$phase==j & TimeEdgelist$hour>16)
        #l1 <- intersect(d1, p1)
        
        # d2 <- which(TimeEdgelist$date == as.character(as.POSIXct(i, format = "%Y-%m-%d") + ddays(1)))
        #p2 <- which(TimeEdgelist$phase ==j & TimeEdgelist$hour<9)
        #l2 <- intersect(d2, p2)
        #l <- union(l1, l2)
      #}
      
      l <- which(TimeEdgelist$phase==j)
      if (k == "short") {su <- which(TimeEdgelist$duration < 25*60)}
      if (k == "long")  {su <- which(TimeEdgelist$duration >= 25*60)}
      ll <- intersect(l, su)
      list <- TimeEdgelist[ll,]
    
        if (length(ll) > 0) {
          
          Adj <- randomize_within_list(list, perm = perm, list_ind = list_ind, community = Community)
          
        }
      
      if (j==phases[1] & k=="short") {
        Arr <- Adj
        nam <- rep(paste0(j, "_", k), (perm+1))
      } else {
        Arr <- DescTools::Abind(Arr, Adj, along = 1)
        nam <- c(nam, rep(paste0(j, "_", k), (perm+1)))
      }
    
    }
    
  }
  
  #print(paste("Done: ", i))
  
#}
dimnames(Arr)[[1]] <- nam



#for (i in unique(dimnames(Arr)[[1]])) {
  
#  mats <- which(dimnames(Arr)[[1]] == i)
  
  for (j in seq(1, (dim(Arr)[1]), (perm+1))) {
    
    k <- j
    while (k<dim(Arr)[1]) {
      
      invisible(capture.output(A <- lowerMat(Arr[j,,])))
      invisible(capture.output(B <- lowerMat(Arr[k,,])))
      r <- lsa::cosine(A,B)
      t <- 0
      for (p in 1:perm) {
        invisible(capture.output(A <- psych::lowerMat(Arr[j+p,,])))
        invisible(capture.output(B <- psych::lowerMat(Arr[k+p,,])))
        v <- lsa::cosine(A, B)
        if (v >= r) {t <- t+1}
      }
    
      if (j==1 & k==1) {
        mosaic.data <- data.frame(X = dimnames(Arr)[[1]][j],
                                  Y = dimnames(Arr)[[1]][k],
                                  R.cosine = r,
                                  P.cosine = t/perm)
      } else {
        mosaic.data <- rbind.data.frame(mosaic.data,
                                        data.frame(X = dimnames(Arr)[[1]][j],
                                                   Y = dimnames(Arr)[[1]][k],
                                                   R.cosine = r,
                                                   P.cosine = t/perm))
      }
      
      k <- k + 101
      
    }
   
    # print(paste0("Type = ", i, ", Date = ", j))
     
  }
  
#}
data.file2 <- mosaic.data
data.file2$R.cosine[data.file2$X==data.file2$Y] <- NA
data.file2$P.cosine[data.file2$X==data.file2$Y] <- NA
data.file2$class <- "white"
data.file2$class[data.file2$P.cosine<0.05] <- "tomato"
data.file2$class[data.file2$P.cosine>0.95] <- "cornflowerblue"
data.file2 <- rbind(data.file2,
                    data.frame(X = data.file2$Y,
                               Y = data.file2$X,
                               R.cosine = data.file2$R.cosine,
                               P.cosine = data.file2$P.cosine,
                               class = data.file2$class))
colnames(data.file2) <- c("phase1", "phase2", "r_mean", "p_value", "class")

#mosaic.data$P.transform <- mosaic.data$P.cosine
#mosaic.data$P.transform[mosaic.data$P.transform > 0.5] <- 1 - mosaic.data$P.transform[mosaic.data$P.transform > 0.5]

#data.file2 <- data.frame()
#for (i in unique(mosaic.data$X)) {
  
#  for (j in unique(mosaic.data$Y)) {
#    
#    r <- mosaic.data$R.cosine[mosaic.data$X==i & mosaic.data$Y==j]
#    s <- mosaic.data$P.transform[mosaic.data$X==i & mosaic.data$Y==j]
#    q <- mosaic.data$P.cosine[mosaic.data$X==i & mosaic.data$Y==j]
#    object <- MeanCI(r, na.rm = T)
#    a <- round(object[1], digits = 4) # mean coefficient of correlation
#    b <- object[2]                    # lower boundary of the CI
#    c <- object[3]                    # upper boundary of the CI
#    d <- MeanAD(r, na.rm = T)         # mean absolute deviation around the mean
#    e <- poolr::bonferroni(s)$p
#    g <- ifelse(e<0.05 & mean(q)<0.5, "cornflowerblue", ifelse(e<0.05 & mean(q)>0.5, "tomato", "white"))
#    
#    data.file2 <- rbind.data.frame(data.file2,
#                                   data.frame(phase1 = i,
#                                              phase2 = j,
#                                              r_mean = a,
#                                              ci_low = b,
#                                              ci_up  = c,
#                                              r_absd = d,
#                                              p_val  = e,
#                                              class  = g))
#    
#  }
#  
#}
# write.csv(x = data.file2, file = "/Users/bordescamille/Desktop/data.file2.csv", quote = F, row.names = F)
```

```{r}
data.file2 <- read.csv("~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_02_Cosine_DayNight_LongShort/data.file2.csv", header = T)
for (i in 1:nrow(data.file2)) {
  data.file2$group.label.y[i] <- ifelse(length(grep(pattern = "day", x = data.file2$phase1[i]))>0, "day", "night")
  data.file2$group.label.x[i] <- ifelse(length(grep(pattern = "day", x = data.file2$phase2[i]))>0, "day", "night")
  data.file2$tick.label.y[i] <- ifelse(length(grep(pattern = "long", x = data.file2$phase1[i]))>0, ">= 25'", "< 25'")
  data.file2$tick.label.x[i] <- ifelse(length(grep(pattern = "long", x = data.file2$phase2[i]))>0, ">= 25'", "< 25'")
}
pha <- c(paste0(phases, "_short"), paste0(phases, "_long"))
data.file2$phase1 <- factor(data.file2$phase1, pha[order(pha)])
data.file2$phase2 <- factor(data.file2$phase2, pha[order(pha)])

a <- ggplot(data.file2, aes(x  = phase2, 
                       y    = phase1, 
                       fill = r_mean)) + 
  geom_tile(width = 0.9, 
            height = 0.9) +
  scale_fill_gradient2(low      = "cornflowerblue", 
                       high     = "tomato", 
                       mid      = "lightyellow", 
                       na.value = "white",
                       midpoint = mean(data.file2$r_mean, na.rm = T), 
                       limit    = c(min(data.file2$r_mean, na.rm = T), max(data.file2$r_mean, na.rm = T)), 
                       breaks   = c(min(data.file2$r_mean, na.rm = T), mean(data.file2$r_mean, na.rm = T), max(data.file2$r_mean, na.rm = T)), 
                       labels   = c(as.character(round(min(data.file2$r_mean, na.rm = T)*100)/100), 
                                    as.character(round(mean(data.file2$r_mean, na.rm = T)*100)/100), 
                                    as.character(round(max(data.file2$r_mean, na.rm = T)*100)/100)), 
                       space    = "Lab",
                       name     = "Cosine similarity index") +
  theme_few() +
  theme(legend.position = "bottom",
        legend.direction = "horizontal")
b <- ggplot(data.file2, 
                       aes(x    = phase2, 
                           y    = phase1, 
                           fill = class)) + 
  geom_tile(width = 0.9, 
            height = 0.9) +
  scale_fill_manual(breaks = c("cornflowerblue", "tomato", "white"),
                    values = c("cornflowerblue", "tomato", "white"),
                    labels = c("Lower than random", 
                               "Higher than random",
                               "Non significant"),
                    name = "Observed value is:") +
  geom_text(aes(x     = phase2, 
                y     = phase1, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +
  theme(
    plot.title          = element_text(hjust = 0.5,
                                       size  = 18),
    axis.text.x         = element_text(angle = 45, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "white"),
    axis.text.y         = element_text(angle = 0, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "white"),
    axis.title.x         = element_blank(),
    axis.title.y         = element_blank(),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.direction     = "vertical",
    legend.position      = "none") +
  ggtitle("Associated p-values")

df.t <- data.file2
a <- ggplot(data = df.t, 
         mapping = aes(x = interaction(tick.label.x, group.label.x), 
                       y = interaction(tick.label.y, group.label.y))) +
  geom_tile(mapping = aes(fill  = r_mean, 
                          width = 0.9, 
                          height = 0.9)) +
  geom_text(data = df.t, aes(x = interaction(tick.label.x, group.label.x), 
                       y = interaction(tick.label.y, group.label.y), 
                       label = round(r_mean*100)/100), size = 9) +
  scale_fill_gradient2(low      = "cornflowerblue", 
                         high     = "tomato", 
                         mid      = "lightyellow", 
                         na.value = "white",
                         midpoint = mean(data.file2$r_mean, na.rm = T), 
                         limit    = c(min(data.file2$r_mean, na.rm = T), max(data.file2$r_mean, na.rm = T)), 
                         breaks   = c(min(data.file2$r_mean, na.rm = T), mean(data.file2$r_mean, na.rm = T), max(data.file2$r_mean, na.rm = T)), 
                         labels   = c(as.character(round(min(data.file2$r_mean, na.rm = T)*100)/100), 
                                      as.character(round(mean(data.file2$r_mean, na.rm = T)*100)/100), 
                                      as.character(round(max(data.file2$r_mean, na.rm = T)*100)/100)), 
                         name     = "Cosine similarity index") +
  scale_x_discrete(labels = c("< 25'", "> 25'", "< 25'", "> 25'")) +
  scale_y_discrete(labels = c("< 25'", "> 25'", "< 25'", "> 25'")) +
  ylab("day                     night") +
  xlab("day                                night") +
  theme(axis.title.x  = element_text(vjust = -5, size = 28),
        axis.title.y  = element_text(vjust = 5, size = 28),
        axis.text.x   = element_text(vjust = -1, size = 25),
        axis.text.y   = element_text(hjust = -1, size = 25),
        plot.margin   = unit(c(1.5, 1.5, 1.5, 1.5), "cm"),
        legend.position = "none")
a
```



# PART 02: Day vs night social structure
Cosine similarity indexes and permutation based p-values for binary and weighted networks
```{r}
sho.list <- subset(TimeEdgelist, duration <= 25*60)
data.day <- subset(sho.list, day_phase %in% c("morning","afternoon"))
data.nig <- subset(sho.list, day_phase %in% c("early_night", "late_night"))
dates    <- levels(as.factor(c(data.day$date, data.nig$date)))[1:28]
perm     <- 1000

for (i in dates) {
  
  # Select the lines for day network and night network that day
  i  <- as.POSIXct(i, format = "%Y-%m-%d")
  d  <- which(data.day$date == i)
  n1 <- intersect(which(data.nig$date==i),         which(data.nig$hour>12))
  n2 <- intersect(which(data.nig$date==i+days(1)), which(data.nig$hour<12))
  
  # Observed lists of interactions
  list_day   <- data.day[d,]
  list_night <- data.nig[c(n1,n2),]
  
  # Creation of the permuted networks
  repeat {
    net_day    <- randomize_within_list(list_day, perm, list_ind, Community)
    test       <- apply(net_day, 1, sum)
    if ( !(0%in%test) ) {break;} 
  }
  repeat {
    net_night  <- randomize_within_list(list_night, perm, list_ind, Community)
    test       <- apply(net_night, 1, sum)
    if ( !(0%in%test) ) {break;}
  }
  net_day_b   <- net_day
  net_night_b <- net_night
  net_day_b[net_day_b!=0] <- 1
  net_night_b[net_night_b!=0] <- 1
  
  if (i == dates[1]) {
    Nets.mosaic.w <- Abind(net_day, net_night, along = 1)
    Nets.mosaic.b <- Abind(net_day_b, net_night_b, along = 1)
    names.dim     <- c(as.POSIXct(i + dhours(11)), as.POSIXct(i + dhours(23)))
  } else {
    Nets.mosaic.w <- Abind(Abind(Nets.mosaic.w, net_day,   along = 1), net_night,   along = 1)
    Nets.mosaic.b <- Abind(Abind(Nets.mosaic.b, net_day_b, along = 1), net_night_b, along = 1)
    names.dim     <- c(names.dim, c(as.POSIXct(i + dhours(11)), as.POSIXct(i + dhours(23))))
  }
  
}

# Calculates network similarity between all potential pairs of networks
m <- 1
for (k in seq(1, dim(Nets.mosaic.w)[1]-((2*perm)+1), (perm+1))) {
  
  n <- m + 1
  for (l in seq(k+(perm+1), dim(Nets.mosaic.w)[1]-perm, (perm+1))) {
    
      invisible(capture.output(A <- lowerMat(Nets.mosaic.w[k,,])))
      invisible(capture.output(B <- lowerMat(Nets.mosaic.w[l,,])))
      invisible(capture.output(C <- lowerMat(Nets.mosaic.b[k,,])))
      invisible(capture.output(D <- lowerMat(Nets.mosaic.b[l,,])))
      r <- lsa::cosine(A, B)
      s <- lsa::cosine(C, D)
      t <- 0
      u <- 0
      for (p in 1:perm) {
        
        invisible(capture.output(A <- lowerMat(Nets.mosaic.w[k+p,,])))
        invisible(capture.output(B <- lowerMat(Nets.mosaic.w[l+p,,])))
        invisible(capture.output(C <- lowerMat(Nets.mosaic.b[k+p,,])))
        invisible(capture.output(D <- lowerMat(Nets.mosaic.b[l+p,,])))
        v <- lsa::cosine(A, B)
        w <- lsa::cosine(C, D)
        if (v < r) {t <- t+1}
        if (w < s) {u <- u+1}
      }
      
      if (m == 1 & n == 2) {
        mosaic.data <- data.frame(X = names.dim[m],
                                  Y = names.dim[n],
                                  R.cosine.w = r,
                                  P.cosine.w = t/perm,
                                  R.cosine.b = s,
                                  P.cosine.b = u/perm)
      } else {
        mosaic.data <- rbind.data.frame(mosaic.data,
                       data.frame(X = names.dim[m],
                                  Y = names.dim[n],
                                  R.cosine.w = r,
                                  P.cosine.w = t/perm,
                                  R.cosine.b = s,
                                  P.cosine.b = u/perm))
      }
      
    n <- n + 1
  }
  
  print(paste0("You have completed ", m, " date(s) out of 54."))
  m <- m + 1
}

mosaic.data5 <- mosaic.data
mosaic.data5$P.transform <- mosaic.data5$P.cosine.w
mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5] <- 1 - mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5]
mosaic.data5$P.adjust <- stats::p.adjust(mosaic.data5$P.transform, method = "fdr")
mosaic.data5$class.w <- "white"
mosaic.data5$class.w[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine.w<0.5] <- "cornflowerblue"
mosaic.data5$class.w[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine.w>0.5] <- "tomato"

mosaic.data5$P.transform <- mosaic.data5$P.cosine.b
mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5] <- 1 - mosaic.data5$P.transform[mosaic.data5$P.transform > 0.5]
mosaic.data5$P.adjust <- stats::p.adjust(mosaic.data5$P.transform, method = "fdr")
mosaic.data5$class.b <- "white"
mosaic.data5$class.b[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine.b<0.5] <- "cornflowerblue"
mosaic.data5$class.b[mosaic.data5$P.transform<0.05 & mosaic.data5$P.cosine.b>0.5] <- "tomato"

mosaic.data2 <- rbind.data.frame(mosaic.data5,
                      data.frame(X = mosaic.data5[,2],
                                 Y = mosaic.data5[,1],
                                 R.cosine.w = mosaic.data5[,3],
                                 P.cosine.w = mosaic.data5[,4],
                                 R.cosine.b = mosaic.data5[,5],
                                 P.cosine.b = mosaic.data5[,6],
                                 P.transform = mosaic.data5[,7],
                                 P.adjust   = mosaic.data5[,8],
                                 class.w    = mosaic.data5[,9],
                                 class.b    = mosaic.data5[,10]))
#write.csv(mosaic.data2, "~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_03_Cosine_DayNight_1month/mosaic.data2.csv")
```

```{r}
mosaic.data2 <- read.csv("~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_03_Cosine_DayNight_1month/mosaic.data2.csv", header = T, stringsAsFactors = F)
mosaic.data2$X <- as.POSIXct(mosaic.data2$X, format = "%Y-%m-%d %H:%M:%S")
mosaic.data2$Y <- as.POSIXct(mosaic.data2$Y, format = "%Y-%m-%d %H:%M:%S")

a <- ggplot(mosaic.data2, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = R.cosine.w)) + 
  geom_tile() +
  scale_fill_gradient2(low      = "cornflowerblue", 
                       high     = "tomato", 
                       mid      = "lightyellow", 
                       na.value = "white",
                       midpoint = mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T), 
                       limit    = c(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T), 
                                    max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)),
                       breaks   = c(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T),
                                    mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T),
                                    max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)),
                       labels   = c(as.character(round(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)*100)/100),
                                    as.character(round(mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T)*100)/100),
                                    as.character(round(max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)*100)/100)),
                       name     = "Similarity index") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +  
  theme(
    plot.title          = element_text(hjust = 0.5,
                                       size = 18),
    axis.text.x         = element_blank(),
    axis.text.y         = element_text(angle = 0, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "black"),
    axis.title.x         = element_blank(),
    axis.title.y         = element_text(size = 20, margin = margin(r=20)),
    plot.margin          = unit(c(0,0,0,0), "cm"),
    panel.spacing        = unit(c(0,0,0,0), "cm"),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.justification = c(1, 0),
    legend.direction     = "horizontal",
    legend.text          = element_text(size = 12),
    legend.title         = element_text(size  = 15)) +
  guides(fill = guide_colorbar(barwidth       = 7, 
                               barheight      = 1,
                               title.position = "top",
                               title.hjust    = 0.5)) +
  ylab("Weighted networks") +
  ggtitle("Cosine similarity indexes")


b <- ggplot(mosaic.data2, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = class.w)) + 
  geom_tile() +
  scale_fill_manual(breaks = c("cornflowerblue", "tomato", "white"),
                    values = c("cornflowerblue", "tomato", "white"),
                    labels = c("Lower than random", 
                               "Higher than random",
                               "Non significant"),
                    name = "Observed value is:") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +
  theme(
    plot.title          = element_text(hjust = 0.5,
                                       size  = 18),
    axis.text.x         = element_blank(),
    axis.text.y         = element_blank(),
    axis.title.x         = element_blank(),
    axis.title.y         = element_blank(),
    plot.margin          = unit(c(0,0,0,0), "cm"),
    panel.spacing        = unit(c(0,0,0,0), "cm"),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.direction     = "vertical",
    legend.key           = element_rect(colour = "black", size = 1)) +
  ggtitle("Associated p-values")

c <- ggplot(mosaic.data2, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = R.cosine.b)) + 
  geom_tile() +
  scale_fill_gradient2(low      = "cornflowerblue", 
                       high     = "tomato", 
                       mid      = "lightyellow", 
                       na.value = "white",
                       midpoint = mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T), 
                       limit    = c(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T), 
                                    max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)),
                       breaks   = c(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T),
                                    mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T),
                                    max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)),
                       labels   = c(as.character(round(min(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)*100)/100),
                                    as.character(round(mean(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b) , na.rm = T)*100)/100),
                                    as.character(round(max(c(mosaic.data2$R.cosine.w, mosaic.data2$R.cosine.b), na.rm = T)*100)/100)),
                       name     = "Similarity index") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +  
  theme(
    plot.title          = element_blank(),
    axis.text.x         = element_text(angle = 45, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "black"),
    axis.text.y         = element_text(angle = 0, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "black"),
    axis.title.x         = element_blank(),
    axis.title.y         = element_text(size = 20, margin = margin(r=20)),
    plot.margin          = unit(c(0,0,0,0), "cm"),
    panel.spacing        = unit(c(0,0,0,0), "cm"),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.justification = c(1, 0),
    legend.direction     = "horizontal",
    legend.position      = "none", 
    legend.text          = element_text(size = 14),
    legend.title         = element_text(size  = 18)) +
  guides(fill = guide_colorbar(barwidth       = 7, 
                               barheight      = 1,
                               title.position = "top",
                               title.hjust    = 0.5)) +
  ylab("Binary networks")


d <- ggplot(mosaic.data2, 
                       aes(x    = Y, 
                           y    = X, 
                           fill = class.b)) + 
  geom_tile() +
  scale_fill_manual(breaks = c("cornflowerblue", "tomato", "white"),
                    values = c("cornflowerblue", "tomato", "white"),
                    labels = c("Lower than random", 
                               "Higher than random",
                               "Non significant"),
                    name = "Observed value is:") +
  geom_text(aes(x     = Y, 
                y     = X, 
                label = ""), 
            color = "black", 
            size  = 1) +
  coord_fixed() +
  theme_few() +
  theme(
    plot.title          = element_blank(),
    axis.text.x         = element_text(angle = 45, 
                                     vjust = 1, 
                                     size  = 15, 
                                     hjust = 1,
                                     color = "black"),
    axis.text.y          = element_blank(),
    axis.title.x         = element_blank(),
    axis.title.y         = element_blank(),
    plot.margin          = unit(c(0,0,0,0), "cm"),
    panel.spacing        = unit(c(-1,-1,-1,-1), "cm"),
    panel.grid.major     = element_blank(),
    panel.border         = element_blank(),
    panel.background     = element_blank(),
    axis.ticks           = element_blank(),
    legend.justification = c(1, 0),
    legend.direction     = "vertical",
    legend.position      = "none",
    legend.key           = element_rect(colour = "black", size = 1) ,
    legend.text          = element_text(size = 12),
    legend.title         = element_text(size  = 15)) +
    guides(fill = guide_legend(title.position = "top",
                               title.hjust    = 0.5))

library("patchwork")
a + b + c + d +
  plot_layout(design = "AB
              CD",
              widths = c(1, 1),
              guides = 'collect')
```



# PART 03: Day vs night network traits
Calculate daily network traits
```{r}
sho.list <- subset(TimeEdgelist, duration <= 25*60)
dates    <- levels(as.factor(sho.list$date))
perm     <- 1000
periods  <- expand.grid(date = dates, phase = c("day", "night"))
periods  <- periods[order(periods$date),]
periods  <- periods[-c(57,58),]
ind_in_l <- unique(c(TimeEdgelist$individual1, TimeEdgelist$individual2))

data.day.night <- list()
for (p in 1:(perm+1)) {
  
  d <- data.frame()
  for (i in 1:nrow(periods)) {
    
    # Calculate the social network from interaction_list
    da       <- as.POSIXct(periods$date[i], format = "%Y-%m-%d")
    ph       <- as.character(periods$phase[i])
    
    if (ph == "day") {
      ll     <- which(sho.list$date==da & sho.list$phase==ph)
    } else {
      n1 <- intersect(which(sho.list$date==da), intersect(which(sho.list$phase==ph), which(sho.list$hour>16)))
      n2 <- intersect(which(sho.list$date==(da+ddays(1))), intersect(which(sho.list$phase==ph), which(sho.list$hour<10)))
      ll <- union(n1, n2)
    }
    interact <- sho.list[ll,]
    
    gbi     <- get_group_by_individual(interact$dyad, data_format = "groups")
    invisible(
      capture.output(
        net <- get_network(association_data  =  gbi, 
                           data_format       = "GBI", 
                           association_index = 'SRI', 
                           identities        = colnames(gbi))
        )
      )
    gra <- graph_from_adjacency_matrix(net, "undirected", weighted = T)
    
    
    names    <- colnames(gbi)
    missing  <- c(setdiff(as.character(ind_in_l), names), 
                  setdiff(names, as.character(ind_in_l)))
    if (length(missing) > 0) {
      gbi1    <- cbind(gbi, 
                      matrix(0, 
                             ncol = length(missing), 
                             nrow = nrow(gbi)))
      colnames(gbi1) <- c(names, as.character(missing))
    }
    invisible(
      capture.output(
        net1 <- get_network(association_data =  gbi1, 
                           data_format       = "GBI", 
                           association_index = 'SRI', 
                           identities        = colnames(gbi1))
        )
      )
    net1 <- net1[order(colnames(net1)),] # sort the rows by names
    net1 <- net1[,order(colnames(net1))] # sort the cols by names
    gra1 <- graph_from_adjacency_matrix(net1, "undirected", weighted = T)
    
    lines         <- match(names(V(gra1)), list_ind$Chip)
    V(gra1)$date   <- as.character(as.POSIXct(periods$date[i], format = "%Y-%m-%d"))
    V(gra1)$site   <- as.character(list_ind$Canyon[lines])
    V(gra1)$phase  <- as.character(periods$phase[i])
    V(gra1)$group  <- as.character(list_ind$Group[lines])
    V(gra1)$sex    <- as.character(list_ind$Sex[lines])
    V(gra1)$weight <- as.numeric(as.character(list_ind$Weight[lines]))
    V(gra1)$smi    <- as.numeric(as.character(list_ind$SMI[lines]))
    V(gra1)$status <- as.factor(list_ind$Social_status[lines])
    
    for (v in names(V(gra1))) {
      
      j      <- as.numeric(Community$nodeclusters$cluster[which(Community$nodeclusters$node==v)])
      soc_en <- unique(Community$nodeclusters$node[which(Community$nodeclusters$cluster %in% j)])
      # node.e <- unique(names(unlist(ego(gra, order = 1, nodes = v, mode = "all"))))
      # soc_en <- unique(c(node.e, node.j))
      
      site <- V(gra1)$site[match(v, names(V(gra1)))]
      invisible(
        capture.output(
          sub_glo <- igraph::subgraph(gra1, v = names(V(gra1))[V(gra1)$site == site])
        )
      )
      sub_glo <- as.undirected(sub_glo, mode = c("collapse"), edge.attr.comb = "ignore")
      sub_adg <- as_adjacency_matrix(sub_glo, attr = "weight")
          
      invisible(
        capture.output(
          sub_loc <- igraph::subgraph(gra1, v = names(V(gra1))[names(V(gra1)) %in% soc_en])
        )
      )
      sub_loc <- as.undirected(sub_loc, mode = c("collapse"), edge.attr.comb = "ignore")
      sub_adl <- as_adjacency_matrix(sub_loc, attr = "weight")
      a       <- as_tbl_graph(sub_loc) %>% activate(edges) %>% activate(nodes)
      a       <- as_tbl_graph(sub_loc) %>% activate(edges) %>% activate(nodes) %>% 
              mutate(id_num_loc           = paste0(j, collapse = "-"),
                     diff_bonds_glo       = sd(sub_adg)/mean(sub_adg),
                     diff_bonds_loc       = sd(sub_adl)/mean(sub_adl),
                     diff_bonds_ind       = sd(sub_adl[match(v, colnames(sub_adl)),])/mean(sub_adl[match(v, colnames(sub_adl)),]),
                     size_tot             = length(names),
                     size_glo             = nrow(sub_adg[rowSums(sub_adg)!=0,]),
                     size_loc             = nrow(sub_adl[rowSums(sub_adl)!=0,]),
                     transitivity_glo     = igraph::transitivity(sub_glo, 
                                                                 type    = "globalundirected", 
                                                                 weights = E(sub_glo)$weight, 
                                                                 vids    = V(sub_glo)),
                     transitivity_loc     = igraph::transitivity(sub_loc,   
                                                                 type    = "globalundirected", 
                                                                 weights = E(sub_loc)$weight,   
                                                                 vids    = V(sub_loc)),
                     transitivity_ind     = local_transitivity(weights = E(sub_loc)$weight),
                     density_glo          = graph.density(sub_glo),
                     density_loc          = graph.density(sub_loc),
                     degree               = igraph::degree(sub_glo)[match(names(V(sub_loc)), names(igraph::degree(sub_glo)))],
                     strength             = centrality_degree(weights = E(sub_loc)$weight, 
                                                              mode    = "all", 
                                                              loops   = FALSE,
                                                              normalized = TRUE),
                     eigen                = centrality_eigen(weights  = E(sub_loc)$weight, 
                                                             directed = FALSE, 
                                                             scale    = TRUE))
      to_keep <- which(v == as.data.frame(a)$name)                                  
      if (v==names(V(gra1))[1]) {
        c <- as.data.frame(as.data.frame(a)[to_keep,])
      } else {
        c <- rbind.data.frame(c, as.data.frame(a)[to_keep,])
      }
      
    }
    
    # Calculates social differentiation
    if (i > 1) {
      for (k in 1:nrow(c)) {
        line              <- match(c$name[k], colnames(net1))
        c$assoc_stab_w[k] <- cor(x = net1[line,], y = net_less[line,], method = "spearman")
        net2 <- net1[line,]
        net3 <- net_less[line,]
        net2[net2>0] <- 1
        net3[net3>0] <- 1
        both   <- length(which(net2+net3==2))
        either <- length(which(net2+net3==2)) + length(which(net2+net3==1))
        c$assoc_stab_b[k] <- both/either
      }
    } else {
      for (k in 1:nrow(c)) {
        line              <- match(c$name[k], colnames(net1))
        c$assoc_stab_w[k] <- NA
        c$assoc_stab_b[k] <- NA
      }
    }
    d <- rbind.data.frame(d, as.data.frame(c))
    net_less <- net1
    
    # Before leaving this loop, perform one swap in the interaction list subset.
    sho.list[ll,]     <- unique_swap(interaction_list = sho.list[ll,], 
                                     list_ind         = list_ind, 
                                     community        = Community)
    print(paste0("period: ", i))
    
  }
  data.day.night <- list.append(data.day.night, d)
  print(paste0("permutation: ", p-1))
  
}
names(data.day.night) <- c("observed", paste0("perm", c(1:(perm))))


OUT <- createWorkbook()
for (index in 1:length(data.day.night)) {
  addWorksheet(OUT, paste("Permutation ", (index-1)))
  writeData(OUT, sheet = paste("Permutation ", (index-1)), x = data.day.night[[index]])
}
# saveWorkbook(OUT, "~/Desktop/data.day.night.bis.xlsx")
```

Omnibus test for network traits comparison
```{r}
data.day.night <- openxlsx::loadWorkbook("~/Desktop/Articles_PhD/Article_01_DayNightContrasts/09_Submission_EcologyLetters/Part_04_NetworkTraits_Permutations/data.day.night.bis.xlsx")
centralities <- c("sd.eigen", "sd.diff_bonds_ind", "sd.degree", "sd.strength",
                  "assoc_stab_b", "assoc_stab_w",
                  "density_loc", "diff_bonds_loc", "diff_bonds_ind",
                  "degree", "strength", "eigen")
Omnibus <- data.frame()
Ds <- c()
Dats <- data.frame()
Difs <- data.frame()
for (central in centralities) {
  
  r.cen.d <- c()
  r.cen.n <- c()
  r.cen.diff <- c()
  for (index in 1:501) {
    data.provi <- openxlsx::readWorkbook(data.day.night, 
                                         sheet = index,
                                         detectDates = TRUE)
    data.provi <- data.provi[order(data.provi$date, data.provi$phase, data.provi$name),]
    
    if (length(grep(pattern = "sd.", x = central))>0) {
      if (central == "sd.eigen") {
        data.prov <- data.provi %>% 
                   group_by(date, phase, id_num_loc) %>%
                   dplyr::summarize(sd = sd(eigen, na.rm = T))
      }
      if (central == "sd.degree") {
        data.prov <- data.provi %>% 
                   group_by(date, phase, id_num_loc) %>%
                   dplyr::summarize(sd = sd(degree, na.rm = T))
      }
      if (central == "sd.strength") {
        data.prov <- data.provi %>% 
                   group_by(date, phase, id_num_loc) %>%
                   dplyr::summarize(sd = sd(strength, na.rm = T))
      }
      if (central == "sd.diff_bonds_ind") {
        data.prov <- data.provi %>% 
                   group_by(date, phase, id_num_loc) %>%
                   dplyr::summarize(sd = sd(diff_bonds_ind, na.rm = T))
      }
      cen.d <- data.prov$sd[data.prov$phase=="day"]
      cen.n <- data.prov$sd[data.prov$phase=="night"]
      cen.diff <- cen.d - cen.n
    } else {
      col   <- match(central, colnames(data.provi))
      if (length(grep(pattern = "assoc_stab", x = central))>0) {
        cen.d <- data.provi[data.provi$phase=="day", col]
        cen.n <- data.provi[data.provi$phase=="night", col]
        cen.diff <- data.provi[, col]
      } else {
        if (length(grep(pattern = "glo", x = central))>0) {
          data.prov <- data.provi[!duplicated(data.provi[,c("date", "phase", "site")]) ,]
          cen.d <- data.prov[data.prov$phase=="day", col]
          cen.n <- data.prov[data.prov$phase=="night", col]
        } else {
          if (length(grep(pattern = "loc", x = central))>0) {
            data.prov <- data.provi[!duplicated(data.provi[,c("date", "phase", "site", "id_num_loc")]) ,]
            cen.d <- data.prov[data.prov$phase=="day", col]
            cen.n <- data.prov[data.prov$phase=="night", col]
          } else {
            cen.d <- data.provi[data.provi$phase=="day", col]
            cen.n <- data.provi[data.provi$phase=="night", col]
          }
        }
      cen.diff <- cen.d-cen.n
      }
    }
    
    print(paste(central, "| permutation", index))
    if (index == 1) {
      o.cen.d <- cen.d
      o.cen.n <- cen.n
      o.cen.diff <- cen.diff
      if (length(grep(pattern = "assoc_stab", x = central))>0) {
        o.cen.diff.dat <- data.frame(observed.diff = cen.diff, 
                                   permuted.diff = NA,
                                   p = 0)
      } else {
        o.cen.diff.dat <- data.frame(observed.diff = abs(cen.diff), 
                                   permuted.diff = NA,
                                   p = 0)
      }
    } else {
      r.cen.d <- c(r.cen.d, cen.d)
      r.cen.n <- c(r.cen.n, cen.n)
      r.cen.diff <- c(r.cen.diff, cen.diff)
      if (length(grep(pattern = "assoc_stab", x = central))>0) {
        o.cen.diff.dat$permuted.diff <- cen.diff
      } else {
        o.cen.diff.dat$permuted.diff <- abs(cen.diff)
      }
      for (ll in 1:nrow(o.cen.diff.dat)) {
        if (!is.na(o.cen.diff.dat$permuted.diff[ll]) & !is.na(o.cen.diff.dat$observed.diff[ll])) {
          if (o.cen.diff.dat$permuted.diff[ll] >= o.cen.diff.dat$observed.diff[ll]) {
            o.cen.diff.dat$p[ll] <- o.cen.diff.dat$p[ll] + 1
          }
        }
      }
    }
  }
  o.cen.diff.dat$p <- o.cen.diff.dat$p/500

  o.cen.d <- data.frame(centrality = central, value = o.cen.d, type  = "obs",  group = "day")
  o.cen.n <- data.frame(centrality = central, value = o.cen.n, type  = "obs",  group = "night")
  o.diff  <- data.frame(centrality = central, value = o.cen.diff, type = "obs")
  Dats <- rbind.data.frame(Dats, o.cen.d, o.cen.n)
  if (length(grep(pattern = "sd.", x = central))>0 | length(grep(pattern = "assoc_stab", x = central))>0) {
    r.cen.d <- data.frame(centrality = central, value = r.cen.d, type  = "rand", group = "day")
    r.cen.n <- data.frame(centrality = central, value = r.cen.n, type  = "rand", group = "night")
    r.diff  <- data.frame(centrality = central, value = r.cen.diff, type = "rand")
    Ds   <- rbind.data.frame(Ds, r.cen.d, r.cen.n, o.cen.d, o.cen.n)
    Difs <- rbind.data.frame(Difs, o.diff, r.diff)
  }
  
  o.cen.diff.dat$p[o.cen.diff.dat$p==0] <- 2e-16
  Omnibus <- rbind.data.frame(Omnibus, 
                              data.frame(
                                centrality = central,
                                ave_obs_diff = mean(abs(o.cen.diff), na.rm = TRUE),
                                std_obs_diff = sd(abs(o.cen.diff), na.rm = TRUE),
                                ave_rand_diff = mean(abs(r.cen.diff), na.rm = TRUE),
                                std_rand_diff = sd(abs(r.cen.diff), na.rm = TRUE),
                                p_value_1 = CombinePValue::competitive.test(na.omit(o.cen.diff.dat$p), Weight = NA),
                                p_value_2 = poolr::bonferroni(na.omit(o.cen.diff.dat$p), adjust = "none")$p,
                                p_value_n = poolr::bonferroni(na.omit(o.cen.diff.dat$p), adjust = "none")$k
                              ))

}
ggplot(Dats, aes(y = group, x = value, fill = group)) +
    geom_boxplot() + facet_grid(facets = .~as.factor(Dats$centrality), scales = "free") +
    coord_flip()
```

```{r}
dat <- data.provi <- openxlsx::readWorkbook(data.day.night, sheet = 1, detectDates = TRUE)
centralities <- c("density_loc", "diff_bonds_loc", "diff_bonds_ind", "degree", "strength", "eigen")
significance <- c("ns", "***", "***", "ns", "***", "***")
y.labs.text  <- c("network density", "group social differentiation", "individual selectivity",
                  "degree centrality", "strength centrality", "eigenvector centrality")
brackets.h   <- c(0.53, 5.4, 2.8, 2.52, 0.69, 1.18)
for (ce in centralities) {
  
  dat$interest <- as.numeric(as.character(dat[, match(ce, colnames(dat))]))
  dat$date     <- as.POSIXct(strptime(dat$date, format = "%Y-%m-%d"))
  dat$phase    <- factor(dat$phase, c("day", "night"))
  dat$hours    <- ifelse(dat$phase == "day", 7, 14)
  dat$time     <- as.POSIXct(dat$date + hours(dat$hours), origin = origin)
  blibli <- dat %>% group_by(time, phase) %>% dplyr::summarize(mean = mean(interest, na.rm = T),
                                                               sd   = sd(interest, na.rm = T),
                                                               se   = MeanSE(interest, na.rm = T),
                                                               CI.u = MeanCI(interest, conf.level = .95, na.rm = T)[3],
                                                               CI.l = MeanCI(interest, conf.level = .95, na.rm = T)[2])

  sp <- ggplot(blibli, aes(x = time, 
                     y = mean, 
                     color = phase)) +
    
    geom_line(color = "grey80") +
    geom_errorbar(aes(ymin = mean - se,
                      ymax = mean + se), 
                  width = 0) +
    geom_point() +
    scale_color_manual(labels = c("day", "night"),
                      values = c("#E69F00", "#56B4E9")) + 
    ylab(y.labs.text[match(ce, centralities)]) +
    theme_pubr()

  yplot <- ggpubr::ggviolin(blibli, 
                             y = "mean",
                             x = "phase",
                             fill = "phase") +
      scale_fill_manual(labels = c("day", "night"),
                        values = c("#E69F00", "#56B4E9")) + 
      geom_bracket(xmin = 0.95, 
                   xmax = 2.05, 
                   y.position = brackets.h[match(ce, centralities)],
                   label = as.character(significance[match(ce, centralities)]),
                   label.size = 4,
                   tip.length = c(0, 0),
                   size = 0.9
      )
  
  if (ce %in% c("diff_bonds_ind", "eigen")) {
    sp    <- sp + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
                   axis.title.y = element_text(size = 18,
                                               vjust = 3),
                   axis.text.y  = element_text(size = 15),
                   axis.title.x = element_text(size = 18,
                                               vjust = -1,
                                               color = "white"),
                   axis.text.x  = element_text(size = 15))
    yplot <- yplot + 
             clean_theme() + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
                   axis.title.y = element_blank(),
                   axis.ticks.y = element_blank(),
                   axis.text.y  = element_blank(),
                   axis.line.y  = element_blank(),
                   axis.title.x = element_text(size = 18,
                                               color = "white"),
                   axis.text.x  = element_text(size = 15)) 
  } else {
    sp    <- sp + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
                   axis.title.x  = element_blank(),
                   axis.ticks.x = element_blank(),
                   axis.text.x  = element_blank(),
                   axis.line.x  = element_blank(),
                   axis.text.y  = element_text(size = 15),
                   axis.title.y = element_text(size = 18,
                                               vjust = 3))
    yplot <- yplot + 
             clean_theme() + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
                   axis.title.y = element_blank(),
                   axis.ticks.y = element_blank(),
                   axis.text.y  = element_blank(),
                   axis.line.y  = element_blank()) 
  }
  assign(x = as.character(paste0("sp.", ce)), value = sp)
  assign(x = as.character(paste0("yplot.", ce)), value = yplot)
  
}

library("cowplot")
plot_grid(sp.density_loc, yplot.density_loc, 
          sp.diff_bonds_loc, yplot.diff_bonds_loc, 
          sp.diff_bonds_ind, yplot.diff_bonds_ind, 
          ncol = 2,
          nrow = 3,
          align = "h", 
          rel_widths = c(3, 1), 
          rel_heights = rep(1, 3))
plot_grid(sp.degree, yplot.degree, 
          sp.strength, yplot.strength, 
          sp.eigen, yplot.eigen, 
          ncol = 2,
          nrow = 3,
          align = "h", 
          rel_widths = c(3, 1), 
          rel_heights = rep(1, 3))
```

```{r}
dat.sd <- dat %>% 
          group_by(date, phase, id_num_loc) %>%
          dplyr::summarize(sd.eigen = sd(eigen, na.rm = T),
                           sd.degree = sd(degree, na.rm = T),
                           sd.strength = sd(strength, na.rm = T),
                           sd.select = sd(diff_bonds_ind, na.rm = T)) %>%
          as.data.frame()
centralities <- c("sd.degree", "sd.strength", "sd.eigen", "sd.select")
significance <- c("***", "***", "***", "***")
y.labs.text  <- c("degree centrality", "strength centrality", "eigenvector centrality", "individual selectiveness")
brackets.h   <- c(2.4, 0.9, 1, 1.3)
for (ce in centralities) {
  
  dat.sd$interest <- as.numeric(as.character(dat.sd[, match(ce, colnames(dat.sd))]))
  dat.sd$date     <- as.POSIXct(strptime(dat.sd$date, format = "%Y-%m-%d"))
  dat.sd$phase    <- factor(dat.sd$phase, c("day", "night"))
  dat.sd$hours    <- ifelse(dat.sd$phase == "day", 7, 14)
  dat.sd$time     <- as.POSIXct(dat.sd$date + hours(dat.sd$hours), origin = origin)
  
  sp <- ggplot(dat.sd, aes(x = time, 
                           y = interest, 
                           fill = phase,
                           color = phase,
                           group = interaction(time, phase))) +
    geom_violin() +
    ylab(y.labs.text[match(ce, centralities)]) +
    theme_pubr()

  yplot <- ggpubr::ggboxplot(dat.sd, 
                            y = "interest",
                            x = "phase",
                            fill = "phase") +
      geom_bracket(xmin = 0.95, 
                   xmax = 2.05, 
                   y.position = brackets.h[match(ce, centralities)],
                   label = as.character(significance[match(ce, centralities)]),
                   label.size = 4,
                   tip.length = c(0, 0),
                   size = 0.9
      )
  
  if (ce %in% c("sd.select")) {
    sp    <- sp + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm"),
                   axis.title.y = element_text(size = 18,
                                               vjust = 3),
                   axis.text.y  = element_text(size = 15),
                   axis.title.x = element_text(size = 18,
                                               vjust = -1),
                   axis.text.x  = element_text(size = 15))
    yplot <- yplot + 
             clean_theme() + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm"),
                   axis.title.y = element_blank(),
                   axis.ticks.y = element_blank(),
                   axis.text.y  = element_blank(),
                   axis.line.y  = element_blank(),
                   axis.title.x = element_text(size = 18,
                                               color = "white"),
                   axis.text.x  = element_text(size = 15)) 
  } else {
    sp    <- sp + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm"),
                   axis.title.x  = element_blank(),
                   axis.ticks.x = element_blank(),
                   axis.text.x  = element_blank(),
                   axis.line.x  = element_blank(),
                   axis.text.y  = element_text(size = 15),
                   axis.title.y = element_text(size = 18,
                                               vjust = 3))
    yplot <- yplot + 
             clean_theme() + 
             rremove("legend") + 
             theme(plot.margin = unit(c(0.2,0.5,0.2,0.5), "cm"),
                   axis.title.y = element_blank(),
                   axis.ticks.y = element_blank(),
                   axis.text.y  = element_blank(),
                   axis.line.y  = element_blank()) 
  }
  assign(x = as.character(paste0("sp.", ce)), value = sp)
  assign(x = as.character(paste0("yplot.", ce)), value = yplot)
  
}

library("cowplot")
plot_grid(sp.sd.degree, yplot.sd.degree,
          sp.sd.strength, yplot.sd.strength,
          sp.sd.eigen, yplot.sd.eigen,
          sp.sd.select, yplot.sd.select,
          ncol = 2,
          nrow = 4,
          align = "h", 
          rel_widths = c(3, 1))
```

```{r}
D1s <- Ds[!is.na(Ds$value) & Ds$type=="obs",]
ys <- c("degree centrality", "eigenvector centrality", "individual selectivity", "strength centrality")
br <- c(2, 0.8, 0.8)
for (central in c("sd.degree", "sd.eigen", "sd.diff_bonds_ind", "sd.strength")) {
  
  D2s <- D1s[D1s$centrality==central,]
  D2s <- D2s[D2s$value>0,]
  brackets <- c(2.6, 0.9, 1, 1.3)
  
  a <- ggpubr::ggboxplot(D2s, 
                   y = "value",
                   x = "group",
                   fill = "group") +
        scale_fill_manual(labels = c("day", "night"),
                          values = c("#E69F00", "#56B4E9")) + 
        geom_bracket(xmin = 0.95, 
                     xmax = 2.05, 
                     y.position = br[match(central, c("sd.degree", "sd.eigen", "sd.diff_bonds_ind", "sd.strength"))],
                     label = "***",
                     label.size = 4,
                     tip.length = c(0, 0),
                     size = 0.9) +
    ylab(as.character(ys[match(central, c("sd.degree", "sd.eigen", "sd.diff_bonds_ind", "sd.strength"))])) +
    theme_pubr() +
    rremove("legend") +
    theme(axis.title.x  = element_blank(),
          axis.ticks.x = element_blank(),
          axis.line.x  = element_blank(),
          axis.text.x  = element_text(size = 15),
          axis.text.y  = element_text(size = 15),
          axis.title.y = element_text(size = 18, vjust = 2),
          plot.margin  = unit(rep(0.5,4), "cm"))
  
  assign(x = as.character(paste0("g.", central)), value = a)
  
}
library("cowplot")
plot_grid(g.sd.degree,
          g.sd.eigen,
          g.sd.diff_bonds_ind,
          ncol = 3,
          nrow = 1,
          align = "h")
```

```{r}
plot.data <- c()
for (index in 1:501) {
  data.provi <- openxlsx::readWorkbook(data.day.night, 
                                         sheet = index,
                                         detectDates = TRUE)
  data.provi <- data.provi[order(data.provi$date, data.provi$phase, data.provi$name),]
  
  plot.data <- rbind.data.frame(
    plot.data,
    cbind.data.frame(
      data.provi[,c("assoc_stab_w", "assoc_stab_b", "name", "date", "phase")],
      data.frame(type = ifelse(index==1, "obs", "rand"))
    )
  )
}
plot.data$date     <- as.POSIXct(strptime(plot.data$date, format = "%Y-%m-%d"))
plot.data$phase    <- factor(plot.data$phase, c("day", "night"))
plot.data$hours    <- ifelse(plot.data$phase == "day", 11, 23)
plot.data$time     <- as.POSIXct(plot.data$date + hours(plot.data$hours), origin = origin)

a <- ggplot(plot.data,
       aes(x = time,
           y = assoc_stab_w,
           group = interaction(time, type),
           fill = type,
           color = type)) +
  geom_boxplot() +
  ylab("Individual selectivity") +
  theme_pubr() +
  rremove("legend") +
  theme(axis.title.x  = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x  = element_blank(),
        axis.text.x  = element_text(size = 15))
b <- ggplot(plot.data,
       aes(x = time,
           y = assoc_stab_b,
           group = interaction(time, type),
           fill = type,
           color = type)) +
  scale_colour_manual(labels = c("observed network traits", "predicted under the null hypothesis"),
                      values = c("#E69F00", "#56B4E9")) +
  scale_fill_manual(labels = c("observed network traits", "predicted under the null hypothesis"),
                    values = c("#E69F00", "#56B4E9")) + 
  geom_boxplot() +
  ylab("Neighbors' stability") +
  theme_pubr() +
  theme(legend.title = element_blank())
  

library("cowplot")
plot_grid(a, b, NULL, NULL,
          ncol = 1,
          nrow = 4,
          align = "hv")
a
```

```{r}
library("patchwork")
sp + yplot +
  plot_layout(design = "AB",
              widths = c(3, 1)) +
  plot_annotation(title = "Title",
                  subtitle = "Subtitle",
                  tag_levels = 'a',
                  tag_suffix = ')')
```

